"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processStreamedMessage = void 0;
const stream_1 = require("@crayonai/stream");
const eventsource_parser_1 = require("eventsource-parser");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
/**
 * @category Utilities
 */
const processStreamedMessage = async ({ response, createMessage, updateMessage, deleteMessage, }) => {
    const stream = response.body?.getReader();
    if (!stream) {
        throw new Error("No stream");
    }
    let isMessagePushed = false;
    let messageId = crypto.randomUUID();
    let previousMessageId = messageId;
    let finalMessage = undefined;
    const onMessageUpdate = (message) => {
        finalMessage = message;
        if (messageId !== message.id) {
            previousMessageId = messageId;
            messageId = message.id;
            deleteMessage(previousMessageId);
            createMessage(message);
            return;
        }
        if (!isMessagePushed) {
            createMessage(message);
        }
        else {
            updateMessage(message);
        }
        isMessagePushed = true;
    };
    let messageContent = [];
    let messageContext = [];
    const parser = (0, eventsource_parser_1.createParser)({
        onEvent: (event) => {
            const lastMessageContent = messageContent[messageContent.length - 1];
            const isLastMessageContentString = lastMessageContent?.type === "text";
            switch (event.event) {
                case stream_1.SSEType.TextDelta: {
                    const textChunk = stream_1.TextChunk.fromSSEData(event.data);
                    if (isLastMessageContentString) {
                        messageContent.pop();
                        messageContent = messageContent.concat({
                            type: "text",
                            text: lastMessageContent.text + textChunk.chunk,
                        });
                    }
                    else {
                        messageContent = messageContent.concat({
                            type: "text",
                            text: textChunk.chunk,
                        });
                    }
                    break;
                }
                case stream_1.SSEType.ResponseTemplate: {
                    const responseTemplate = stream_1.ResponseTemplate.fromSSEData(event.data);
                    messageContent = messageContent.concat({
                        type: "template",
                        name: responseTemplate.name,
                        templateProps: responseTemplate.templateProps,
                    });
                    break;
                }
                case stream_1.SSEType.ResponseTemplatePropsChunk: {
                    const responseTemplateProps = stream_1.ResponseTemplatePropsChunk.fromSSEData(event.data);
                    (0, tiny_invariant_1.default)(lastMessageContent?.type === "template", "response template expected");
                    messageContent.pop();
                    messageContent = messageContent.concat({
                        type: "template",
                        name: lastMessageContent.name,
                        templateProps: {
                            ...(lastMessageContent.templateProps || {}),
                            content: (lastMessageContent.templateProps?.content || "") + responseTemplateProps.chunk,
                        },
                    });
                    break;
                }
                case stream_1.SSEType.ContextAppend: {
                    const ctxUpdate = stream_1.ContextUpdate.fromSSEData(event.data);
                    messageContext = messageContext.concat(ctxUpdate.contextItem);
                    break;
                }
                case stream_1.SSEType.MessageUpdate: {
                    const messageUpdate = stream_1.MessageUpdate.fromSSEData(event.data);
                    messageId = messageUpdate.id;
                    break;
                }
                default: {
                    console.warn(`Unknown event type: ${event.event}`);
                    break;
                }
            }
            onMessageUpdate({
                id: messageId,
                role: "assistant",
                message: messageContent,
                context: messageContext,
            });
        },
    });
    const decoder = new TextDecoder();
    while (true) {
        const { done, value } = await stream.read();
        parser.feed(decoder.decode(value, { stream: !done }));
        if (done) {
            parser.reset({ consume: true });
            break;
        }
    }
    return finalMessage;
};
exports.processStreamedMessage = processStreamedMessage;
//# sourceMappingURL=processStreamedMessage.js.map