"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useThreadListManager = void 0;
const react_1 = require("react");
const zustand_1 = require("zustand");
/**
 * `useThreadListManager` takes the necessary arguments and helps create a {@link ThreadListManager} instance. This instance is necessary to define how a thread list should
 * be fetched, updated, deleted, and selected and which backend APIs should be called at any of these events or actions.
 *
 * @category Hooks
 * @returns A ThreadListManager instance
 */
const useThreadListManager = (params) => {
    const propsRef = (0, react_1.useRef)(params);
    propsRef.current = params;
    const store = (0, react_1.useMemo)(() => {
        return (0, zustand_1.createStore)((set, get) => {
            const updateThreadRunningStatus = (id, isRunning) => {
                set((state) => ({
                    threads: state.threads.map((t) => {
                        if (t.threadId !== id) {
                            return t;
                        }
                        return {
                            ...t,
                            isRunning,
                        };
                    }),
                }));
            };
            return {
                selectedThreadId: null,
                shouldResetThreadState: false,
                threads: [],
                error: null,
                isLoading: true,
                selectThread: (threadId, shouldLoadThread = true) => {
                    set({ selectedThreadId: threadId, shouldResetThreadState: shouldLoadThread });
                    propsRef.current.onSelectThread(threadId);
                },
                load: () => {
                    set({ isLoading: true });
                    propsRef.current
                        .fetchThreadList()
                        .then((threads) => {
                        const existingThreads = store.getState().threads;
                        set({ isLoading: false, threads: mergeThreadList(existingThreads, threads) });
                    })
                        .catch((e) => {
                        set({ isLoading: false, error: e });
                    });
                },
                createThread: async (firstMessage) => {
                    const thread = await propsRef.current.createThread(firstMessage);
                    set((state) => ({
                        threads: mergeThreadList(state.threads, [thread]),
                    }));
                    return thread;
                },
                deleteThread: (id) => {
                    updateThreadRunningStatus(id, true);
                    propsRef.current
                        .deleteThread(id)
                        .then(() => {
                        const state = get();
                        set({
                            threads: state.threads.filter((t) => t.threadId !== id),
                        });
                        if (state.selectedThreadId === id) {
                            state.switchToNewThread();
                        }
                    })
                        .catch(() => {
                        updateThreadRunningStatus(id, false);
                    });
                },
                updateThread: (thread) => {
                    updateThreadRunningStatus(thread.threadId, true);
                    propsRef.current
                        .updateThread(thread)
                        .then((thread) => set((state) => ({
                        threads: state.threads.map((t) => (t.threadId === thread.threadId ? thread : t)),
                    })))
                        .catch(() => {
                        updateThreadRunningStatus(thread.threadId, false);
                    });
                },
                switchToNewThread: () => {
                    set({ selectedThreadId: null, shouldResetThreadState: true });
                    propsRef.current.onSwitchToNew();
                },
            };
        });
    }, []);
    return (0, zustand_1.useStore)(store);
};
exports.useThreadListManager = useThreadListManager;
const mergeThreadList = (existingThreads, newThreads) => {
    return Array.from(new Map([...existingThreads, ...newThreads].map((t) => [t.threadId, t])).values()).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
};
//# sourceMappingURL=useThreadListManager.js.map