import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { MessageProvider, useThreadActions, useThreadManagerSelector, useThreadState, } from "@crayonai/react-core";
import clsx from "clsx";
import { ArrowRight, Square } from "lucide-react";
import { memo, useLayoutEffect, useRef } from "react";
import { useComposerState } from "../../hooks/useComposerState";
import { useScrollToBottom } from "../../hooks/useScrollToBottom";
import { IconButton } from "../IconButton";
import { MessageLoading as MessageLoadingComponent } from "../MessageLoading";
import { useShellStore } from "./store";
export const ThreadContainer = ({ children, className, }) => {
    return _jsx("div", { className: clsx("crayon-shell-thread-container", className), children: children });
};
export const ScrollArea = ({ children, className, scrollVariant = "user-message-anchor", userMessageSelector, }) => {
    const ref = useRef(null);
    const { messages, isRunning, isLoadingMessages } = useThreadState();
    useScrollToBottom({
        ref,
        lastMessage: messages[messages.length - 1] || { id: "" },
        scrollVariant,
        userMessageSelector,
        isRunning,
        isLoadingMessages,
    });
    return (_jsx("div", { ref: ref, className: clsx("crayon-shell-thread-scroll-area", {
            "crayon-shell-thread-scroll-area--user-message-anchor": scrollVariant === "user-message-anchor",
        }, className), children: children }));
};
const FallbackTemplate = ({ name, templateProps }) => {
    return (_jsxs("div", { children: ["Unable to render template: ", name, " with props:", JSON.stringify(templateProps)] }));
};
const DefaultTextRenderer = ({ children, className, }) => {
    return _jsx("div", { className: className, children: children });
};
export const AssistantMessageContainer = ({ children, className, }) => {
    const { logoUrl } = useShellStore((store) => ({
        logoUrl: store.logoUrl,
    }));
    return (_jsxs("div", { className: clsx("crayon-shell-thread-message-assistant", className), children: [_jsx("img", { src: logoUrl, alt: "Assistant", className: "crayon-shell-thread-message-assistant__logo" }), _jsx("div", { className: "crayon-shell-thread-message-assistant__content", children: children })] }));
};
export const UserMessageContainer = ({ children, className, }) => {
    return (_jsx("div", { className: clsx("crayon-shell-thread-message-user", className), children: _jsx("div", { className: "crayon-shell-thread-message-user__content", children: children }) }));
};
export const RenderMessage = memo(({ message, className }) => {
    const responseTemplates = useThreadManagerSelector((store) => store.responseTemplates);
    const MessageContainer = message.role === "user" ? UserMessageContainer : AssistantMessageContainer;
    if (message.role === "assistant") {
        return (_jsx(MessageContainer, { className: className, children: message.message?.map((stringOrTemplate, i) => {
                if (stringOrTemplate.type === "text") {
                    const TextRenderer = responseTemplates["text"]?.Component || DefaultTextRenderer;
                    return (_jsx(TextRenderer, { className: "crayon-shell-thread-message-assistant__text", children: stringOrTemplate.text }, i));
                }
                const Template = responseTemplates[stringOrTemplate.name];
                const Fallback = responseTemplates["fallback"]?.Component || FallbackTemplate;
                return Template ? (_jsx(Template.Component, { ...stringOrTemplate.templateProps }, i)) : (_jsx(Fallback, { name: stringOrTemplate.name, templateProps: stringOrTemplate.templateProps }, i));
            }) }));
    }
    return _jsx(MessageContainer, { children: message.message });
});
export const MessageLoading = () => {
    return (_jsx("div", { className: "crayon-shell-thread-message-loading", children: _jsx(MessageLoadingComponent, {}) }));
};
export const Messages = ({ className, loader, }) => {
    const { messages, isRunning } = useThreadState();
    return (_jsxs("div", { className: clsx("crayon-shell-thread-messages", className), children: [messages.map((message) => {
                if (message.isVisuallyHidden) {
                    return null;
                }
                return (_jsx(MessageProvider, { message: message, children: _jsx(RenderMessage, { message: message }) }, message.id));
            }), isRunning && _jsx("div", { children: loader })] }));
};
export const Composer = ({ className }) => {
    const { textContent, setTextContent } = useComposerState();
    const { processMessage, onCancel } = useThreadActions();
    const { isRunning, isLoadingMessages } = useThreadState();
    const inputRef = useRef(null);
    const handleSubmit = () => {
        if (!textContent.trim() || isRunning || isLoadingMessages) {
            return;
        }
        processMessage({
            type: "prompt",
            role: "user",
            message: textContent,
        });
        setTextContent("");
    };
    useLayoutEffect(() => {
        const input = inputRef.current;
        if (!input) {
            return;
        }
        input.style.height = "0px";
        input.style.height = `${input.scrollHeight}px`;
    }, [textContent]);
    return (_jsx("div", { className: clsx("crayon-shell-thread-composer", className), children: _jsxs("div", { className: "crayon-shell-thread-composer__input-wrapper", children: [_jsx("textarea", { ref: inputRef, value: textContent, onChange: (e) => setTextContent(e.target.value), className: "crayon-shell-thread-composer__input", placeholder: "Type your message...", onKeyDown: (e) => {
                        if (e.key === "Enter" && !e.shiftKey) {
                            e.preventDefault();
                            handleSubmit();
                        }
                    } }), _jsx(IconButton, { onClick: isRunning ? onCancel : handleSubmit, icon: isRunning ? _jsx(Square, { size: "1em", fill: "currentColor" }) : _jsx(ArrowRight, { size: "1em" }) })] }) }));
};
//# sourceMappingURL=Thread.js.map