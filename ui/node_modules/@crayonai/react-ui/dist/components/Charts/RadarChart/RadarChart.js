import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { memo, useEffect, useMemo, useRef, useState } from "react";
import { PolarAngleAxis, PolarGrid, Radar, RadarChart as RechartsRadarChart, } from "recharts";
import { ChartContainer, ChartTooltip } from "../Charts";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useTransformedKeys } from "../hooks/useTransformKey";
import { ActiveDot, CustomTooltipContent, DefaultLegend } from "../shared";
import { useChartPalette } from "../utils/PalletUtils";
import { get2dChartConfig, getDataKeys, getLegendItems } from "../utils/dataUtils";
import { AxisLabel } from "./components/AxisLabel";
const MIN_CHART_SIZE = 150;
const MAX_CHART_SIZE = 296;
const RadarChartComponent = ({ data, categoryKey, theme = "ocean", customPalette, variant = "line", grid = true, legend = true, strokeWidth = 2, areaOpacity = 0.2, icons = {}, isAnimationActive = false, height, width, }) => {
    const dataKeys = useMemo(() => {
        return getDataKeys(data, categoryKey);
    }, [data, categoryKey]);
    const transformedKeys = useTransformedKeys(dataKeys);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "radarChartPalette",
        dataLength: dataKeys.length,
    });
    // Create Config
    const chartConfig = useMemo(() => {
        return get2dChartConfig(dataKeys, colors, transformedKeys, undefined, icons);
    }, [dataKeys, icons, colors, transformedKeys]);
    const legendItems = useMemo(() => {
        return getLegendItems(dataKeys, colors, icons);
    }, [dataKeys, colors, icons]);
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const wrapperRef = useRef(null);
    const [wrapperRect, setWrapperRect] = useState({ width: 0, height: 0 });
    useEffect(() => {
        const wrapper = wrapperRef.current;
        if (!wrapper)
            return;
        const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            if (entry) {
                setWrapperRect({
                    width: entry.contentRect.width,
                    height: entry.contentRect.height,
                });
            }
        });
        observer.observe(wrapper);
        return () => observer.disconnect();
    }, []);
    const chartSize = useMemo(() => {
        const effectiveWidth = wrapperRect.width;
        const effectiveHeight = wrapperRect.height;
        let charts = Math.min(effectiveWidth, effectiveHeight);
        charts = Math.min(charts, MAX_CHART_SIZE);
        return Math.max(MIN_CHART_SIZE, charts);
    }, [wrapperRect]);
    const chartSizeStyle = useMemo(() => ({ width: chartSize, height: chartSize }), [chartSize]);
    const rechartsProps = useMemo(() => ({
        width: "100%",
        height: "100%",
        minWidth: 1,
        minHeight: 1,
        initialDimension: { width: 1, height: 1 },
    }), []);
    const radars = useMemo(() => {
        return dataKeys.map((key) => {
            const transformedKey = transformedKeys[key];
            const color = `var(--color-${transformedKey})`;
            if (variant === "line") {
                return (_jsx(Radar, { dataKey: key, fill: color, fillOpacity: 0, stroke: color, strokeWidth: strokeWidth, isAnimationActive: isAnimationActive, activeDot: _jsx(ActiveDot, {}) }, key));
            }
            else {
                return (_jsx(Radar, { dataKey: key, fill: color, stroke: color, strokeWidth: strokeWidth, fillOpacity: areaOpacity, isAnimationActive: isAnimationActive, activeDot: _jsx(ActiveDot, {}) }, key));
            }
        });
    }, [dataKeys, transformedKeys, variant, strokeWidth, areaOpacity, isAnimationActive]);
    const wrapperClassName = useMemo(() => clsx("crayon-radar-chart-container-wrapper", {
        "layout-column": true,
    }), []);
    const wrapperStyle = useMemo(() => {
        const formatDimension = (value) => {
            if (typeof value === "number") {
                return `${value}px`;
            }
            return value;
        };
        const dimensions = {
            width: formatDimension(width),
            height: formatDimension(height),
        };
        if (dimensions.width === undefined) {
            delete dimensions.width;
        }
        if (dimensions.height === undefined) {
            delete dimensions.height;
        }
        return dimensions;
    }, [width, height]);
    return (_jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: false, setIsSideBarTooltipOpen: () => { }, data: undefined, setData: () => { }, children: _jsxs("div", { ref: wrapperRef, className: wrapperClassName, style: wrapperStyle, children: [_jsx("div", { className: "crayon-radar-chart-container", children: _jsx("div", { className: "crayon-radar-chart-container-inner", children: _jsx("div", { style: chartSizeStyle, children: _jsx(ChartContainer, { config: chartConfig, className: "crayon-radar-chart", rechartsProps: rechartsProps, children: _jsxs(RechartsRadarChart, { data: data, margin: {
                                        left: 10,
                                        right: 10,
                                        top: 10,
                                        bottom: 10,
                                    }, children: [grid && _jsx(PolarGrid, { className: "crayon-chart-polar-grid", stroke: "currentColor" }), _jsx(PolarAngleAxis, { dataKey: categoryKey, tick: _jsx(AxisLabel, { portalContainerRef: wrapperRef }) }), _jsx(ChartTooltip, { cursor: false, content: _jsx(CustomTooltipContent, { parentRef: wrapperRef }) }), radars] }) }) }) }) }), legend && (_jsx(DefaultLegend, { items: legendItems, containerWidth: wrapperRect.width, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded, style: { paddingTop: 0 } }))] }) }));
};
export const RadarChart = memo(RadarChartComponent);
RadarChart.displayName = "RadarChart";
//# sourceMappingURL=RadarChart.js.map