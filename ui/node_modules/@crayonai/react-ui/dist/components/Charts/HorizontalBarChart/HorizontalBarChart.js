import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Bar, BarChart as RechartsBarChart, XAxis, YAxis } from "recharts";
import { useId } from "../../../polyfills";
import { useTheme } from "../../ThemeProvider";
import { ChartContainer, ChartTooltip } from "../Charts";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useTransformedKeys } from "../hooks";
import { useHorizontalBarLabelHeight } from "../hooks/useMaxLabelHeight";
import { CustomTooltipContent, DefaultLegend, SideBarTooltip, verticalCartesianGrid, YAxisTick, } from "../shared";
import { ScrollButtonsVertical } from "../shared/ScrollButtonsVertical";
import { useChartPalette } from "../utils/PalletUtils";
import { LabelTooltipProvider } from "../shared/LabelTooltip/LabelTooltip";
import { findNearestSnapPosition, getBarStackInfo, getRadiusArray, } from "../utils/BarCharts/BarChartsUtils";
import { get2dChartConfig, getColorForDataKey, getDataKeys, getLegendItems, } from "../utils/dataUtils";
import { numberTickFormatter } from "../utils/styleUtils";
import { CustomBarShape } from "./components/CustomBarShape";
import { useMaxCategoryLabelWidth } from "./hooks/useMaxCategoryLabelWidth";
import { BAR_GAP, BAR_HEIGHT, getHeightOfData, getPadding, getSnapPositions, } from "./utils/HorizontalBarChartUtils";
const X_AXIS_HEIGHT = 40; // Height of X-axis chart when shown
const BAR_CATEGORY_GAP = "20%"; // Gap between categories
const BAR_INTERNAL_LINE_WIDTH = 1;
const BAR_RADIUS = 4;
const HorizontalBarChartComponent = ({ data, categoryKey, theme = "ocean", customPalette, variant = "grouped", grid = true, icons = {}, radius = BAR_RADIUS, isAnimationActive = false, showXAxis = true, xAxisLabel, yAxisLabel, legend = true, className, height, width, }) => {
    const maxCategoryLabelWidth = useMaxCategoryLabelWidth(data, categoryKey);
    const chartContainerRef = useRef(null);
    const mainContainerRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const [canScrollUp, setCanScrollUp] = useState(false);
    const [canScrollDown, setCanScrollDown] = useState(false);
    const [hoveredCategory, setHoveredCategory] = useState(null);
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const [isSideBarTooltipOpen, setIsSideBarTooltipOpen] = useState(false);
    const [sideBarTooltipData, setSideBarTooltipData] = useState({
        title: "",
        values: [],
    });
    // Calculate chart width for internal calculations (legend, xAxis, etc.)
    const effectiveWidth = useMemo(() => {
        return width ?? containerWidth;
    }, [width, containerWidth]);
    // Calculate label height for better group height calculation
    // Use chart width for label height calculation since labels span full width
    const labelHeight = useHorizontalBarLabelHeight(data, categoryKey, effectiveWidth);
    const dataKeys = useMemo(() => {
        return getDataKeys(data, categoryKey);
    }, [data, categoryKey]);
    const transformedKeys = useTransformedKeys(dataKeys);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "barChartPalette",
        dataLength: dataKeys.length,
    });
    const chartConfig = useMemo(() => {
        return get2dChartConfig(dataKeys, colors, transformedKeys, undefined, icons);
    }, [dataKeys, icons, colors, transformedKeys]);
    // Use provided height or observed height
    const effectiveHeight = useMemo(() => {
        return height ?? 296 + X_AXIS_HEIGHT;
    }, [height]);
    // Calculate effective container height (excluding X-axis)
    const effectiveContainerHeight = useMemo(() => {
        const xAxisHeight = showXAxis ? X_AXIS_HEIGHT : 0;
        return Math.max(0, effectiveHeight - xAxisHeight);
    }, [effectiveHeight, showXAxis]);
    const padding = useMemo(() => {
        return getPadding(data, categoryKey, effectiveContainerHeight, variant, labelHeight);
    }, [data, categoryKey, effectiveContainerHeight, variant, labelHeight]);
    const dataHeight = useMemo(() => {
        return getHeightOfData(data, categoryKey, variant, labelHeight);
    }, [data, categoryKey, variant, labelHeight]);
    // Calculate snap positions for proper group alignment
    const snapPositions = useMemo(() => {
        return getSnapPositions(data, categoryKey, variant, labelHeight);
    }, [data, categoryKey, variant, labelHeight]);
    // Check scroll boundaries
    const updateScrollState = useCallback(() => {
        if (mainContainerRef.current) {
            const { scrollTop, scrollHeight, clientHeight } = mainContainerRef.current;
            setCanScrollUp(scrollTop > 0);
            setCanScrollDown(scrollTop < scrollHeight - clientHeight - 1);
        }
    }, []);
    const scrollUp = useCallback(() => {
        if (mainContainerRef.current) {
            const currentScroll = mainContainerRef.current.scrollTop;
            const targetIndex = findNearestSnapPosition(snapPositions, currentScroll, "up");
            const targetPosition = snapPositions[targetIndex] ?? 0;
            mainContainerRef.current.scrollTo({
                top: targetPosition,
                behavior: "smooth",
            });
        }
    }, [snapPositions]);
    const scrollDown = useCallback(() => {
        if (mainContainerRef.current) {
            const currentScroll = mainContainerRef.current.scrollTop;
            const targetIndex = findNearestSnapPosition(snapPositions, currentScroll, "down");
            const targetPosition = snapPositions[targetIndex] ?? 0;
            mainContainerRef.current.scrollTo({
                top: targetPosition,
                behavior: "smooth",
            });
        }
    }, [snapPositions]);
    useEffect(() => {
        // Set up ResizeObserver if height or width is not provided
        if (!chartContainerRef.current) {
            return () => { };
        }
        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                if (!width) {
                    setContainerWidth(entry.contentRect.width);
                }
            }
        });
        resizeObserver.observe(chartContainerRef.current);
        return () => {
            resizeObserver.disconnect();
        };
    }, [height, width]);
    // Update scroll state when container dimensions or data height changes
    useEffect(() => {
        updateScrollState();
    }, [effectiveContainerHeight, dataHeight, containerWidth, updateScrollState]);
    useEffect(() => {
        setIsSideBarTooltipOpen(false);
        setIsLegendExpanded(false);
    }, [dataKeys]);
    // Add scroll event listener to update button states
    useEffect(() => {
        const mainContainer = mainContainerRef.current;
        if (!mainContainer)
            return;
        const handleScroll = () => {
            updateScrollState();
        };
        mainContainer.addEventListener("scroll", handleScroll);
        return () => {
            mainContainer.removeEventListener("scroll", handleScroll);
        };
    }, [updateScrollState]);
    // Memoize legend items creation
    const legendItems = useMemo(() => {
        return getLegendItems(dataKeys, colors, icons);
    }, [dataKeys, colors, icons]);
    const id = useId();
    const xAxis = useMemo(() => {
        if (!showXAxis) {
            return null;
        }
        return (_jsx("div", { className: "crayon-horizontal-bar-chart-x-axis-container", children: _jsx(ChartContainer, { config: chartConfig, style: { width: "100%", height: X_AXIS_HEIGHT }, rechartsProps: {
                    height: X_AXIS_HEIGHT,
                }, children: _jsxs(RechartsBarChart, { data: data, layout: "vertical", margin: {
                        top: 0,
                        bottom: 0,
                        left: 5,
                        right: 2,
                    }, stackOffset: "sign", children: [_jsx(XAxis, { type: "number", height: X_AXIS_HEIGHT, tickLine: false, axisLine: false, tickFormatter: numberTickFormatter, tick: { fontSize: 12 } }), dataKeys.map((key) => {
                            return (_jsx(Bar, { dataKey: key, fill: "transparent", stackId: variant === "stacked" ? "a" : undefined, isAnimationActive: false, maxBarSize: 0 }, `x-axis-horizontal-bar-chart-${key}`));
                        })] }, `x-axis-horizontal-bar-chart-${id}`) }) }));
    }, [showXAxis, chartConfig, data, dataKeys, variant, id]);
    // Handle mouse events for group hovering
    const handleChartMouseMove = useCallback((state) => {
        if (state && state.activeLabel !== undefined) {
            setHoveredCategory(state.activeLabel);
        }
    }, []);
    const handleChartMouseLeave = useCallback(() => {
        setHoveredCategory(null);
    }, []);
    const { mode } = useTheme();
    const barInternalLineColor = useMemo(() => {
        if (mode === "light") {
            return "rgba(255, 255, 255, 0.3)";
        }
        return "rgba(0, 0, 0, 0.3)";
    }, [mode]);
    const onBarsClick = useCallback((data) => {
        if (data?.activePayload?.length && data.activePayload.length > 10) {
            setIsSideBarTooltipOpen(true);
            setSideBarTooltipData({
                title: data.activeLabel,
                values: data.activePayload.map((payload) => ({
                    value: payload.value,
                    label: payload.name || payload.dataKey,
                    color: getColorForDataKey(payload.dataKey, dataKeys, colors),
                })),
            });
        }
    }, [dataKeys, colors]);
    const setLabelWidth = useCallback(() => { }, []);
    return (_jsx(LabelTooltipProvider, { children: _jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: isSideBarTooltipOpen, setIsSideBarTooltipOpen: setIsSideBarTooltipOpen, data: sideBarTooltipData, setData: setSideBarTooltipData, children: _jsxs("div", { className: clsx("crayon-horizontal-bar-chart-container", className), children: [_jsxs("div", { className: "crayon-horizontal-bar-chart-container-inner-wrapper", style: {
                            height: height ? `${height}px` : effectiveHeight,
                        }, children: [_jsxs("div", { className: "crayon-horizontal-bar-chart-container-inner", ref: chartContainerRef, children: [_jsx("div", { className: "crayon-horizontal-bar-chart-main-container", ref: mainContainerRef, children: _jsx(ChartContainer, { config: chartConfig, style: { height: dataHeight, minHeight: "100%", width: "100%" }, children: _jsxs(RechartsBarChart, { accessibilityLayer: true, data: data, layout: "vertical", onClick: onBarsClick, onMouseMove: handleChartMouseMove, onMouseLeave: handleChartMouseLeave, barGap: BAR_GAP, barCategoryGap: BAR_CATEGORY_GAP, margin: {
                                                    top: 0,
                                                    bottom: 0,
                                                    left: 2,
                                                    right: 2,
                                                }, stackOffset: "sign", children: [grid && verticalCartesianGrid(), _jsx(XAxis, { type: "number", tickLine: false, axisLine: false, hide: true }), _jsx(YAxis, { type: "category", dataKey: categoryKey, tickLine: false, axisLine: false, width: maxCategoryLabelWidth, tick: _jsx(YAxisTick, { setLabelWidth: setLabelWidth }), interval: 0, 
                                                        // gives the padding on the 2 sides see the function for reference
                                                        padding: padding, hide: true }), _jsx(ChartTooltip, { cursor: {
                                                            fill: "var(--crayon-sunk-fills)",
                                                            stroke: "var(--crayon-stroke-default)",
                                                            opacity: 1,
                                                            strokeWidth: 1,
                                                        }, content: _jsx(CustomTooltipContent, { parentRef: mainContainerRef }), offset: 15 }), dataKeys.map((key, index) => {
                                                        const transformedKey = transformedKeys[key];
                                                        const color = `var(--color-${transformedKey})`;
                                                        return (_jsx(Bar, { dataKey: key, fill: color, stackId: variant === "stacked" ? "a" : undefined, isAnimationActive: isAnimationActive, maxBarSize: BAR_HEIGHT, barSize: BAR_HEIGHT, shape: (props) => {
                                                                const { payload, value, dataKey } = props;
                                                                const { isNegative, isFirstInStack, isLastInStack } = getBarStackInfo(variant, value, dataKey, payload, dataKeys);
                                                                const customRadius = getRadiusArray(variant, radius, "horizontal", isFirstInStack, isLastInStack, isNegative);
                                                                return (_jsx(CustomBarShape, { ...props, radius: customRadius, index: index, categoryKey: categoryKey, effectiveWidth: effectiveWidth, labelHeight: labelHeight, barInternalLineColor: barInternalLineColor, internalLineWidth: BAR_INTERNAL_LINE_WIDTH, hoveredCategory: hoveredCategory, variant: variant }));
                                                            } }, `main-${key}`));
                                                    })] }, `horizontal-bar-chart-${id}`) }) }), xAxis] }), _jsx(ScrollButtonsVertical, { dataHeight: dataHeight, effectiveHeight: effectiveContainerHeight, canScrollUp: canScrollUp, canScrollDown: canScrollDown, isSideBarTooltipOpen: isSideBarTooltipOpen, onScrollUp: scrollUp, onScrollDown: scrollDown }), isSideBarTooltipOpen && _jsx(SideBarTooltip, { height: effectiveHeight })] }), legend && (_jsx(DefaultLegend, { items: legendItems, yAxisLabel: yAxisLabel, xAxisLabel: xAxisLabel, containerWidth: effectiveWidth, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded }))] }) }) }));
};
// Added React.memo for performance optimization to avoid unnecessary re-renders
export const HorizontalBarChart = React.memo(HorizontalBarChartComponent);
//# sourceMappingURL=HorizontalBarChart.js.map