import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Separator } from "../../Separator";
import { DefaultLegend } from "../shared/DefaultLegend/DefaultLegend";
import { FloatingUIPortal } from "../shared/PortalTooltip";
import { StackedLegend } from "../shared/StackedLegend/StackedLegend";
import { useChartPalette } from "../utils/PalletUtils";
import { ToolTip } from "./components";
export const SingleStackedBar = ({ data, categoryKey, dataKey, theme = "ocean", customPalette, legend = true, legendVariant = "default", className, style, animated = true, }) => {
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const [activeIndex, setActiveIndex] = useState(null);
    const [hoveredLegendKey, setHoveredLegendKey] = useState(null);
    const wrapperRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const [tooltipPosition, setTooltipPosition] = useState(null);
    useEffect(() => {
        const wrapper = wrapperRef.current;
        if (!wrapper)
            return;
        const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            if (entry) {
                setContainerWidth(entry.contentRect.width);
            }
        });
        observer.observe(wrapper);
        return () => observer.disconnect();
    }, []);
    // Calculate percentages
    const segments = useMemo(() => {
        if (!data || data.length === 0) {
            return [];
        }
        const total = data.reduce((acc, item) => acc + Number(item[dataKey]), 0);
        return data.map((item, index) => ({
            value: Number(item[dataKey]),
            category: String(item[categoryKey]),
            index,
            percentage: total > 0 ? (Number(item[dataKey]) / total) * 100 : 0,
        }));
    }, [data, dataKey, categoryKey]);
    // Get theme colors for each segment
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "barChartPalette",
        dataLength: Math.max(segments.length, 1),
    });
    // Create legend items
    const legendItems = useMemo(() => {
        return segments.map((segment, index) => ({
            key: `${segment.category}-${index}`,
            label: segment.category,
            color: colors[index % colors.length] || "",
            percentage: segment.percentage,
        }));
    }, [segments, colors]);
    // Create stacked legend items with values
    const stackedLegendItems = useMemo(() => segments.map((segment, index) => ({
        key: `${segment.category}-${index}`,
        label: segment.category,
        value: segment.value,
        color: colors[index % colors.length] || "",
    })), [segments, colors]);
    // Handle legend item hover with tooltip positioning
    const handleLegendItemHover = useCallback((hoverIndex) => {
        setActiveIndex(hoverIndex);
        if (hoverIndex !== null) {
            const segment = segments[hoverIndex];
            if (segment) {
                const legendKey = `${segment.category}-${hoverIndex}`;
                setHoveredLegendKey(legendKey);
            }
            // Try to position tooltip above the hovered segment
            const segmentEl = wrapperRef.current?.querySelectorAll(".crayon-single-stacked-bar-chart-segment")?.[hoverIndex];
            if (segmentEl) {
                const rect = segmentEl.getBoundingClientRect();
                const containerRect = wrapperRef.current?.getBoundingClientRect();
                if (containerRect) {
                    const relativeX = rect.left + rect.width / 2 - containerRect.left;
                    const relativeY = rect.top - containerRect.top;
                    setTooltipPosition({ x: relativeX, y: relativeY });
                }
                else {
                    setTooltipPosition({ x: rect.left + rect.width / 2, y: rect.top });
                }
            }
        }
        else {
            setHoveredLegendKey(null);
            setTooltipPosition(null);
        }
    }, [segments]);
    // Segmented progress bar
    return (_jsxs("div", { ref: wrapperRef, className: clsx("crayon-single-stacked-bar-chart-container", className, {
            "crayon-single-stacked-bar-chart-container-gap": legend && legendVariant === "default",
        }), style: style, children: [_jsx("div", { className: "crayon-single-stacked-bar-chart", children: segments.map((segment, index) => {
                    const isActive = activeIndex === null || activeIndex === index;
                    return (_jsx("div", { className: clsx("crayon-single-stacked-bar-chart-segment", {
                            "crayon-single-stacked-bar-chart-animated": animated,
                        }), style: {
                            width: `${segment.percentage}%`,
                            backgroundColor: colors[index % colors.length],
                            opacity: isActive ? 1 : 0.5,
                        }, onMouseEnter: (e) => {
                            setActiveIndex(index);
                            const legendKey = `${segment.category}-${index}`;
                            setHoveredLegendKey(legendKey);
                            const rect = e.currentTarget.getBoundingClientRect();
                            const containerRect = wrapperRef.current?.getBoundingClientRect();
                            if (containerRect) {
                                // Position relative to container so FloatingUIPortal aligns correctly
                                const relativeX = rect.left + rect.width / 2 - containerRect.left;
                                const relativeY = rect.top - containerRect.top;
                                setTooltipPosition({ x: relativeX, y: relativeY });
                            }
                            else {
                                setTooltipPosition({ x: rect.left + rect.width / 2, y: rect.top });
                            }
                        }, onMouseLeave: () => {
                            setActiveIndex(null);
                            setHoveredLegendKey(null);
                        }, children: _jsx("div", { className: "crayon-single-stacked-bar-chart-segment-line" }) }, `segment-${index}`));
                }) }), activeIndex !== null && tooltipPosition && (_jsx(FloatingUIPortal, { position: tooltipPosition, placement: "top", offsetDistance: 10, children: _jsx(ToolTip, { label: legendItems[activeIndex]?.label ?? "", color: stackedLegendItems[activeIndex]?.color ?? "#000000", value: stackedLegendItems[activeIndex]?.value ?? 0, percentage: segments[activeIndex]?.percentage ?? 0 }) })), legend && legendVariant === "default" && _jsx(Separator, {}), legend && legendVariant === "default" && (_jsx(DefaultLegend, { items: legendItems, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded, containerWidth: containerWidth, style: { paddingTop: 0 } })), legend && legendVariant === "stacked" && (_jsx(StackedLegend, { items: stackedLegendItems, containerWidth: containerWidth, onItemHover: setHoveredLegendKey, activeKey: hoveredLegendKey, onLegendItemHover: handleLegendItemHover, separator: true, showTitle: false, layout: "showMore", className: "crayon-single-stacked-bar-chart-stacked-legend" }))] }));
};
//# sourceMappingURL=SingleStackedBarChart.js.map