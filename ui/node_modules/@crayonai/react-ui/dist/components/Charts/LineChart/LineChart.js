import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Line, LineChart as RechartsLineChart, XAxis, YAxis } from "recharts";
import { useId } from "../../../polyfills";
import { ChartContainer, ChartTooltip } from "../Charts";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useMaxLabelHeight, useTransformedKeys, useYAxisLabelWidth } from "../hooks";
import { ActiveDot, cartesianGrid, CustomTooltipContent, DefaultLegend, ScrollButtonsHorizontal, SideBarTooltip, XAxisTick, YAxisTick, } from "../shared";
import { LabelTooltipProvider } from "../shared/LabelTooltip/LabelTooltip";
import { findNearestSnapPosition, getSnapPositions, getWidthOfData, getWidthOfGroup, } from "../utils/AreaAndLine/AreaAndLineUtils";
import { useChartPalette } from "../utils/PalletUtils";
import { get2dChartConfig, getColorForDataKey, getDataKeys, getLegendItems, } from "../utils/dataUtils";
const X_AXIS_PADDING = 36;
const CHART_CONTAINER_BOTTOM_MARGIN = 10;
export const LineChart = ({ data, categoryKey, theme = "ocean", customPalette, variant = "natural", tickVariant = "multiLine", grid = true, icons = {}, isAnimationActive = false, showYAxis = true, xAxisLabel, yAxisLabel, legend = true, className, height, width, strokeWidth = 2, }) => {
    const dataKeys = useMemo(() => {
        return getDataKeys(data, categoryKey);
    }, [data, categoryKey]);
    const { yAxisWidth, setLabelWidth } = useYAxisLabelWidth(data, dataKeys);
    const widthOfGroup = useMemo(() => {
        return getWidthOfGroup(data);
    }, [data]);
    const maxLabelHeight = useMaxLabelHeight(data, categoryKey, tickVariant, widthOfGroup);
    const transformedKeys = useTransformedKeys(dataKeys);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "lineChartPalette",
        dataLength: dataKeys.length,
    });
    const chartConfig = useMemo(() => {
        return get2dChartConfig(dataKeys, colors, transformedKeys, undefined, icons);
    }, [dataKeys, icons, colors, transformedKeys]);
    const chartContainerRef = useRef(null);
    const mainContainerRef = useRef(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const [canScrollLeft, setCanScrollLeft] = useState(false);
    const [canScrollRight, setCanScrollRight] = useState(false);
    const [isSideBarTooltipOpen, setIsSideBarTooltipOpen] = useState(false);
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const [sideBarTooltipData, setSideBarTooltipData] = useState({
        title: "",
        values: [],
    });
    // Use provided width or observed width
    const effectiveWidth = useMemo(() => {
        return width ?? containerWidth;
    }, [width, containerWidth]);
    const effectiveContainerWidth = useMemo(() => {
        const dynamicYAxisWidth = showYAxis ? yAxisWidth : 0;
        return Math.max(0, effectiveWidth - dynamicYAxisWidth - 40); // -40 because we are giving 20px padding in xAxis on each side
    }, [effectiveWidth, showYAxis, yAxisWidth]);
    const dataWidth = useMemo(() => {
        return getWidthOfData(data, effectiveContainerWidth);
    }, [data, effectiveContainerWidth]);
    // Calculate snap positions for proper scrolling alignment
    const snapPositions = useMemo(() => {
        return getSnapPositions(data);
    }, [data]);
    const chartHeight = useMemo(() => {
        return height ?? 296 + maxLabelHeight;
    }, [height, maxLabelHeight]);
    // Check scroll boundaries
    const updateScrollState = useCallback(() => {
        if (mainContainerRef.current) {
            const { scrollLeft, scrollWidth, clientWidth } = mainContainerRef.current;
            setCanScrollLeft(scrollLeft > 0);
            setCanScrollRight(scrollLeft < scrollWidth - clientWidth - 1); // -1 for floating point precision
        }
    }, []);
    const scrollLeft = useCallback(() => {
        if (mainContainerRef.current) {
            const currentScroll = mainContainerRef.current.scrollLeft;
            const targetIndex = findNearestSnapPosition(snapPositions, currentScroll, "left");
            const targetPosition = snapPositions[targetIndex] ?? 0;
            mainContainerRef.current.scrollTo({
                left: targetPosition,
                behavior: "smooth",
            });
        }
    }, [snapPositions]);
    const scrollRight = useCallback(() => {
        if (mainContainerRef.current) {
            const currentScroll = mainContainerRef.current.scrollLeft;
            const targetIndex = findNearestSnapPosition(snapPositions, currentScroll, "right");
            const targetPosition = snapPositions[targetIndex] ?? 0;
            mainContainerRef.current.scrollTo({
                left: targetPosition,
                behavior: "smooth",
            });
        }
    }, [snapPositions]);
    useEffect(() => {
        // Only set up ResizeObserver if width is not provided
        if (width || !chartContainerRef.current) {
            return () => { };
        }
        const resizeObserver = new ResizeObserver((entries) => {
            // there is only one entry in the entries array because we are observing the chart container
            for (const entry of entries) {
                setContainerWidth(entry.contentRect.width);
            }
        });
        resizeObserver.observe(chartContainerRef.current);
        return () => {
            resizeObserver.disconnect();
        };
    }, [width]);
    // Update scroll state when container width or data width changes
    useEffect(() => {
        updateScrollState();
    }, [effectiveWidth, dataWidth, updateScrollState]);
    useEffect(() => {
        setIsSideBarTooltipOpen(false);
        setIsLegendExpanded(false);
    }, [dataKeys]);
    // Add scroll event listener to update button states
    useEffect(() => {
        const mainContainer = mainContainerRef.current;
        if (!mainContainer)
            return;
        const handleScroll = () => {
            updateScrollState();
        };
        mainContainer.addEventListener("scroll", handleScroll);
        return () => {
            mainContainer.removeEventListener("scroll", handleScroll);
        };
    }, [updateScrollState]);
    const legendItems = useMemo(() => {
        return getLegendItems(dataKeys, colors, icons);
    }, [dataKeys, colors, icons]);
    const id = useId();
    const onLineClick = useCallback((data) => {
        if (data?.activePayload?.length && data.activePayload.length > 10) {
            setIsSideBarTooltipOpen(true);
            setSideBarTooltipData({
                title: data.activeLabel,
                values: data.activePayload.map((payload) => ({
                    value: payload.value,
                    label: payload.name || payload.dataKey,
                    color: getColorForDataKey(payload.dataKey, dataKeys, colors),
                })),
            });
        }
    }, [dataKeys, colors]);
    const yAxis = useMemo(() => {
        if (!showYAxis) {
            return null;
        }
        return (_jsx("div", { className: "crayon-line-chart-y-axis-container", children: _jsxs(RechartsLineChart, { width: yAxisWidth, height: chartHeight, data: data, margin: {
                    top: 20,
                    bottom: maxLabelHeight + CHART_CONTAINER_BOTTOM_MARGIN, // this is required for to give space for x-axis
                    left: 0,
                    right: 0,
                }, onClick: onLineClick, children: [_jsx(YAxis, { width: yAxisWidth, tickLine: false, axisLine: false, tick: _jsx(YAxisTick, { setLabelWidth: setLabelWidth }) }), dataKeys.map((key) => {
                        return (_jsx(Line, { dataKey: key, type: variant, stroke: "transparent", strokeWidth: 0, dot: false, activeDot: false, isAnimationActive: isAnimationActive }, `y-axis-${key}`));
                    })] }, `y-axis-chart-${id}`) }));
    }, [
        showYAxis,
        id,
        chartHeight,
        data,
        onLineClick,
        dataKeys,
        variant,
        isAnimationActive,
        maxLabelHeight,
        yAxisWidth,
    ]);
    return (_jsx(LabelTooltipProvider, { children: _jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: isSideBarTooltipOpen, setIsSideBarTooltipOpen: setIsSideBarTooltipOpen, data: sideBarTooltipData, setData: setSideBarTooltipData, children: _jsxs("div", { className: clsx("crayon-line-chart-container", className), style: {
                    width: width ? `${width}px` : undefined,
                }, children: [_jsxs("div", { className: "crayon-line-chart-container-inner", ref: chartContainerRef, children: [yAxis, _jsx("div", { className: "crayon-line-chart-main-container", ref: mainContainerRef, children: _jsx(ChartContainer, { config: chartConfig, style: { width: dataWidth, minWidth: "100%", height: chartHeight }, rechartsProps: {
                                        width: "100%",
                                        height: "100%",
                                        minHeight: 1,
                                        minWidth: 1,
                                        initialDimension: { width: 1, height: 1 },
                                    }, children: _jsxs(RechartsLineChart, { accessibilityLayer: true, data: data, margin: {
                                            top: 20,
                                            bottom: CHART_CONTAINER_BOTTOM_MARGIN,
                                        }, onClick: onLineClick, children: [grid && cartesianGrid(), _jsx(XAxis, { dataKey: categoryKey, tickLine: false, axisLine: false, height: maxLabelHeight, textAnchor: "middle", interval: 0, tick: _jsx(XAxisTick, { variant: tickVariant, widthOfGroup: widthOfGroup, labelHeight: maxLabelHeight }), orientation: "bottom", padding: {
                                                    left: X_AXIS_PADDING,
                                                    right: X_AXIS_PADDING,
                                                } }), _jsx(ChartTooltip, { content: _jsx(CustomTooltipContent, { parentRef: mainContainerRef }), offset: 15 }), dataKeys.map((key) => {
                                                const transformedKey = transformedKeys[key];
                                                const color = `var(--color-${transformedKey})`;
                                                return (_jsx(Line, { dataKey: key, type: variant, stroke: color, strokeWidth: strokeWidth, dot: false, activeDot: _jsx(ActiveDot, {}, `active-dot-${key}-${id}`), isAnimationActive: isAnimationActive }, `main-${key}`));
                                            })] }, `line-chart-${id}`) }) }), isSideBarTooltipOpen && _jsx(SideBarTooltip, { height: chartHeight })] }), _jsx(ScrollButtonsHorizontal, { dataWidth: dataWidth, effectiveWidth: effectiveWidth, canScrollLeft: canScrollLeft, canScrollRight: canScrollRight, isSideBarTooltipOpen: isSideBarTooltipOpen, onScrollLeft: scrollLeft, onScrollRight: scrollRight }), legend && (_jsx(DefaultLegend, { items: legendItems, yAxisLabel: yAxisLabel, xAxisLabel: xAxisLabel, containerWidth: effectiveWidth, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded }))] }) }) }));
};
//# sourceMappingURL=LineChart.js.map