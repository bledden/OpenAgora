import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Cell, PolarGrid, RadialBar, RadialBarChart } from "recharts";
import { ChartContainer, ChartTooltip, ChartTooltipContent } from "../Charts";
import { useTransformedKeys } from "../hooks";
import { DefaultLegend } from "../shared/DefaultLegend/DefaultLegend";
import { StackedLegend } from "../shared/StackedLegend/StackedLegend";
import { getCategoricalChartConfig } from "../utils/dataUtils";
import { useChartPalette } from "../utils/PalletUtils";
import { calculateRadialChartDimensions, createRadialAnimationConfig, createRadialEventHandlers, getRadialHoverStyles, transformRadialDataWithPercentages, useRadialChartHover, } from "./utils/RadialChartUtils";
const STACKED_LEGEND_BREAKPOINT = 400;
const MIN_CHART_SIZE = 150;
const MAX_CHART_SIZE = 500;
export const RadialChart = ({ data, categoryKey, dataKey, theme = "ocean", customPalette, variant = "circular", format = "number", legend = true, legendVariant = "stacked", grid = false, isAnimationActive = false, cornerRadius = 10, onMouseEnter, onMouseLeave, onClick, className, maxChartSize = MAX_CHART_SIZE, minChartSize = MIN_CHART_SIZE, height, width, }) => {
    const wrapperRef = useRef(null);
    const [wrapperRect, setWrapperRect] = useState({ width: 0, height: 0 });
    const [hoveredLegendKey, setHoveredLegendKey] = useState(null);
    const [isLegendExpanded, setIsLegendExpanded] = useState(false);
    const { activeIndex, handleMouseEnter, handleMouseLeave } = useRadialChartHover();
    // Determine layout mode based on container width
    const isRowLayout = legend && legendVariant === "stacked" && wrapperRect.width >= STACKED_LEGEND_BREAKPOINT;
    // Sort data by value (highest to lowest) for radial chart rendering
    const sortedProcessedData = useMemo(() => [...data].sort((a, b) => Number(b[dataKey]) - Number(a[dataKey])), [data, dataKey]);
    const categories = useMemo(() => sortedProcessedData.map((item) => String(item[categoryKey])), [sortedProcessedData, categoryKey]);
    const transformedKeys = useTransformedKeys(categories);
    // Memoize string conversions to avoid repeated calls
    const categoryKeyString = useMemo(() => String(categoryKey), [categoryKey]);
    const dataKeyString = useMemo(() => String(dataKey), [dataKey]);
    const formatKey = useMemo(() => (format === "percentage" ? "percentage" : dataKeyString), [format, dataKeyString]);
    // Use provided dimensions or observed dimensions from the wrapper
    const effectiveWidth = wrapperRect.width;
    const effectiveHeight = wrapperRect.height;
    // Calculate chart dimensions based on the smaller dimension of the container
    const chartSize = useMemo(() => {
        // Compute the available width for the chart. In row layout, chart and legend sit side-by-side.
        // Subtract the 20px gap defined in CSS to avoid over-estimating available width.
        const containerWidth = isRowLayout ? Math.max(0, (effectiveWidth - 20) / 2) : effectiveWidth;
        // If wrapper height isn't explicitly provided (or is very small), prefer sizing by width to
        // avoid a feedback loop where height depends on the chart, which then clamps the size.
        const heightIsUsable = effectiveHeight >= minChartSize;
        let size = heightIsUsable ? Math.min(containerWidth, effectiveHeight) : containerWidth;
        size = Math.min(size, maxChartSize);
        return Math.max(minChartSize, size);
    }, [effectiveWidth, effectiveHeight, isRowLayout]);
    const chartSizeStyle = useMemo(() => ({
        width: chartSize,
        height: chartSize,
    }), [chartSize]);
    const rechartsProps = useMemo(() => ({
        width: "100%",
        height: "100%",
        minWidth: 1,
        minHeight: 1,
        initialDimension: { width: 1, height: 1 },
    }), []);
    // Calculate chart radii
    const dimensions = useMemo(() => calculateRadialChartDimensions(chartSize), [chartSize]);
    // Memoize expensive data transformations and configurations
    const transformedData = useMemo(() => transformRadialDataWithPercentages(sortedProcessedData, dataKey, theme), [sortedProcessedData, dataKey, theme]);
    const chartConfig = useMemo(() => getCategoricalChartConfig(sortedProcessedData, categoryKey, theme, transformedKeys), [sortedProcessedData, categoryKey, theme, transformedKeys]);
    const animationConfig = useMemo(() => createRadialAnimationConfig({ isAnimationActive }), [isAnimationActive]);
    const eventHandlers = useMemo(() => createRadialEventHandlers(onMouseEnter, onMouseLeave, onClick), [onMouseEnter, onMouseLeave, onClick]);
    // Get color palette and distribute colors
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "radialChartPalette",
        dataLength: sortedProcessedData.length,
    });
    // Create legend items for both variants
    const legendItems = useMemo(() => sortedProcessedData.map((item, index) => ({
        key: String(item[categoryKey]),
        label: String(item[categoryKey]),
        value: Number(item[dataKey]),
        color: colors[index] || "#000000",
    })), [sortedProcessedData, categoryKey, dataKey, colors]);
    const defaultLegendItems = useMemo(() => {
        return legendItems.map(({ key, label, color }) => ({ key, label, color }));
    }, [legendItems]);
    // Handle legend item hover to highlight radial bar
    const handleLegendItemHover = useCallback((index) => {
        if (legendVariant !== "stacked")
            return;
        if (index !== null) {
            const item = sortedProcessedData[index];
            if (item) {
                const categoryValue = String(item[categoryKey]);
                setHoveredLegendKey(categoryValue);
                // Find the index in the transformed data (which is also sorted)
                const transformedIndex = transformedData.findIndex((d) => String(d[categoryKey]) === categoryValue);
                if (transformedIndex !== -1) {
                    handleMouseEnter(transformedData[transformedIndex], transformedIndex);
                }
            }
        }
        else {
            setHoveredLegendKey(null);
            handleMouseLeave();
        }
    }, [
        sortedProcessedData,
        categoryKey,
        transformedData,
        handleMouseEnter,
        handleMouseLeave,
        legendVariant,
    ]);
    // Enhanced chart hover handlers
    const handleChartMouseEnter = useCallback((entry, index) => {
        handleMouseEnter(entry, index);
        if (legend && legendVariant === "stacked") {
            setHoveredLegendKey(String(entry[categoryKey]));
        }
        eventHandlers.onMouseEnter?.(entry, index);
    }, [handleMouseEnter, categoryKey, legend, legendVariant, eventHandlers.onMouseEnter]);
    const handleChartMouseLeave = useCallback(() => {
        handleMouseLeave();
        if (legend && legendVariant === "stacked") {
            setHoveredLegendKey(null);
        }
        eventHandlers.onMouseLeave?.();
    }, [handleMouseLeave, legend, legendVariant, eventHandlers.onMouseLeave]);
    // Setup ResizeObserver to watch the wrapper element
    useEffect(() => {
        const wrapper = wrapperRef.current;
        if (!wrapper)
            return;
        // Use ResizeObserver if component is in responsive mode (no fixed width/height)
        const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            if (entry) {
                setWrapperRect({
                    width: entry.contentRect.width,
                    height: entry.contentRect.height,
                });
            }
        });
        observer.observe(wrapper);
        return () => observer.disconnect();
    }, []);
    const renderLegend = useCallback(() => {
        if (!legend)
            return null;
        if (legendVariant === "stacked") {
            return (_jsx("div", { className: "crayon-radial-chart-legend-container", children: _jsx(StackedLegend, { items: legendItems, onItemHover: setHoveredLegendKey, activeKey: hoveredLegendKey, onLegendItemHover: handleLegendItemHover, containerWidth: isRowLayout ? undefined : wrapperRect.width }) }));
        }
        return (_jsx(DefaultLegend, { items: defaultLegendItems, containerWidth: wrapperRect.width, isExpanded: isLegendExpanded, setIsExpanded: setIsLegendExpanded }));
    }, [
        legend,
        legendVariant,
        legendItems,
        hoveredLegendKey,
        handleLegendItemHover,
        wrapperRect.width,
        isRowLayout,
        defaultLegendItems,
        isLegendExpanded,
    ]);
    const wrapperClassName = clsx("crayon-radial-chart-container-wrapper", className, {
        "layout-row": isRowLayout,
        "layout-column": !isRowLayout,
        "legend-default": legend && legendVariant === "default",
        "legend-stacked": legend && legendVariant === "stacked",
    });
    // Correct angles for semicircle (top half)
    const startAngle = variant === "semicircle" ? 180 : 0;
    const endAngle = variant === "semicircle" ? 0 : 360;
    const wrapperStyle = useMemo(() => {
        const formatDimension = (value) => {
            if (typeof value === "number") {
                return `${value}px`;
            }
            return value;
        };
        const dimensions = {
            width: formatDimension(width),
            height: formatDimension(height),
        };
        if (dimensions.width === undefined) {
            delete dimensions.width;
        }
        if (dimensions.height === undefined) {
            delete dimensions.height;
        }
        return dimensions;
    }, [width, height]);
    return (_jsxs("div", { ref: wrapperRef, className: wrapperClassName, style: wrapperStyle, "aria-description": "radial-chart-wrapper", children: [_jsx("div", { className: "crayon-radial-chart-container", children: _jsx("div", { className: "crayon-radial-chart-container-inner", children: _jsx("div", { style: chartSizeStyle, children: _jsx(ChartContainer, { config: chartConfig, className: "crayon-radial-chart", rechartsProps: rechartsProps, children: _jsxs(RadialBarChart, { data: transformedData, startAngle: startAngle, endAngle: endAngle, innerRadius: dimensions.innerRadius, outerRadius: dimensions.outerRadius, children: [grid && _jsx(PolarGrid, { gridType: "circle" }), _jsx(ChartTooltip, { cursor: false, content: _jsx(ChartTooltipContent, { showPercentage: format === "percentage", nameKey: categoryKeyString }) }), _jsx(RadialBar, { dataKey: formatKey, background: !grid, cornerRadius: cornerRadius, ...animationConfig, activeIndex: activeIndex ?? undefined, onMouseEnter: handleChartMouseEnter, onMouseLeave: handleChartMouseLeave, onClick: eventHandlers.onClick, children: transformedData.map((entry, index) => {
                                            const categoryValue = String(entry[categoryKey] || "");
                                            const config = chartConfig[categoryValue];
                                            const hoverStyles = getRadialHoverStyles(index, activeIndex);
                                            const fill = config?.color || colors[index];
                                            return (_jsx(Cell, { fill: fill, ...hoverStyles, stroke: "none" }, `cell-${index}`));
                                        }) })] }) }) }) }) }), renderLegend()] }));
};
//# sourceMappingURL=RadialChart.js.map