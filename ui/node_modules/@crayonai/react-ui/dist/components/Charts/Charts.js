import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import clsx from "clsx";
import { uniqueId } from "lodash-es";
import { createContext, forwardRef, useContext, useMemo } from "react";
import * as RechartsPrimitive from "recharts";
import { useId } from "../../polyfills";
import { useTheme } from "../ThemeProvider";
/**
 * @module Charts
 * A collection of chart components built on top of Recharts with enhanced styling and theming capabilities.
 */
/**
 * Available themes for chart customization
 * @constant
 * @type {Record<'light' | 'dark', string>}
 */
const THEMES = { light: "", dark: ".dark" };
const ChartContext = createContext(null);
/**
 * Hook to access chart context
 * @throws Error if used outside of ChartContainer
 */
function useChart() {
    const context = useContext(ChartContext);
    if (!context) {
        throw new Error("useChart must be used within a <ChartContainer />");
    }
    return context;
}
/**
 * Component that generates theme-specific styles for chart elements
 */
const ChartStyle = ({ id, config }) => {
    const colorConfig = Object.entries(config).filter(([_, config]) => config.theme || config.color);
    if (!colorConfig.length) {
        return null;
    }
    return (_jsx("style", { dangerouslySetInnerHTML: {
            __html: Object.entries(THEMES)
                .map(([theme, prefix]) => `
    ${prefix} [data-chart=${id}] {
    ${colorConfig
                .map(([_, itemConfig]) => {
                const transformedKey = itemConfig.transformed;
                const themeValue = itemConfig.theme?.[theme];
                const color = typeof themeValue === "string" ? themeValue : themeValue?.color || itemConfig.color;
                const secondaryColor = typeof themeValue === "object"
                    ? themeValue?.secondaryColor
                    : "secondaryColor" in itemConfig
                        ? itemConfig.secondaryColor
                        : undefined;
                return [
                    color ? `  --color-${transformedKey}: ${color};` : null,
                    secondaryColor ? `  --color-${transformedKey}-secondary: ${secondaryColor};` : null,
                ]
                    .filter(Boolean)
                    .join("\n");
            })
                .filter(Boolean)
                .join("\n")}
    }
    `)
                .join("\n"),
        } }));
};
/**
 * Container component for charts that provides configuration context and styling
 */
const ChartContainer = forwardRef(({ id, className, children, config, rechartsProps, style, ...props }, ref) => {
    const uniqueId = useId();
    const chartId = `crayon-chart-${id || uniqueId.replace(/:/g, "")}`;
    const { theme } = useTheme();
    return (_jsx(ChartContext.Provider, { value: { config, id: chartId }, children: _jsxs("div", { "data-chart": chartId, ref: ref, className: clsx("crayon-chart-container", className), style: {
                "--crayon-container-fills": theme.containerFills,
                "--crayon-primary-text": theme.primaryText,
                width: "100%",
                height: "100%",
                ...style,
            }, ...props, children: [_jsx(ChartStyle, { id: chartId, config: config }), _jsx(RechartsPrimitive.ResponsiveContainer, { width: rechartsProps?.width ?? "100%", height: rechartsProps?.height ?? "100%", minWidth: rechartsProps?.minWidth ?? 1, minHeight: rechartsProps?.minHeight ?? 1, initialDimension: rechartsProps?.initialDimension ?? { width: 1, height: 1 }, id: rechartsProps?.id ?? chartId, ...rechartsProps, children: children })] }) }));
});
ChartContainer.displayName = "Chart";
/**
 * Re-exported Tooltip component from Recharts
 */
const ChartTooltip = RechartsPrimitive.Tooltip;
/**
 * Custom tooltip content component with enhanced styling and formatting
 */
const ChartTooltipContent = forwardRef(({ active, payload, className, indicator = "dot", hideLabel = false, hideIndicator = false, label, labelFormatter, labelClassName, formatter, color, nameKey, labelKey, showPercentage = false, }, ref) => {
    const { config } = useChart();
    const tooltipLabel = useMemo(() => {
        if (hideLabel || !payload?.length) {
            return null;
        }
        const [item] = payload;
        const key = `${labelKey ?? item?.dataKey ?? item?.name ?? "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);
        const value = !labelKey && typeof label === "string" ? config[label]?.label || label : itemConfig?.label;
        if (labelFormatter) {
            return (_jsx("div", { className: clsx("crayon-chart-tooltip-label-heavy", labelClassName), children: labelFormatter(value, payload) }));
        }
        if (!value) {
            return null;
        }
        return _jsx("div", { className: clsx("crayon-chart-tooltip-label", labelClassName), children: value });
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);
    if (!active || !payload?.length) {
        return null;
    }
    const nestLabel = payload.length === 1 && indicator !== "dot";
    return (_jsxs("div", { ref: ref, className: clsx("crayon-chart-tooltip", className), children: [!nestLabel && tooltipLabel, _jsx("div", { className: "crayon-chart-tooltip-content", children: payload.map((item, index) => {
                    const key = `${nameKey ?? item.name ?? item.dataKey ?? "value"}`;
                    const itemConfig = getPayloadConfigFromPayload(config, item, key);
                    const indicatorColor = (color ?? item.payload.fill) || item.color;
                    return (_jsx("div", { className: clsx("crayon-chart-tooltip-content-item", indicator === "dot" && "crayon-chart-tooltip-content-item--dot"), children: formatter && item?.value !== undefined && item.name ? (formatter(item.value, item.name, item, index, item.payload)) : (_jsxs(_Fragment, { children: [itemConfig?.icon ? (_jsx(itemConfig.icon, {})) : (!hideIndicator && (_jsx("div", { className: clsx("crayon-chart-tooltip-content-indicator", `crayon-chart-tooltip-content-indicator--${indicator}`), style: {
                                        "--color-bg": indicatorColor,
                                        "--color-border": indicatorColor,
                                    } }))), _jsxs("div", { className: clsx("crayon-chart-tooltip-content-value-wrapper", nestLabel
                                        ? "crayon-chart-tooltip-content-value-wrapper--nested"
                                        : "crayon-chart-tooltip-content-value-wrapper--standard"), children: [_jsxs("div", { className: "crayon-chart-tooltip-content-label", children: [nestLabel && tooltipLabel, _jsx("span", { children: itemConfig?.label || item.name })] }), item.value !== undefined && (_jsxs("span", { className: clsx("crayon-chart-tooltip-content-value", showPercentage && "percentage"), children: [item.value.toLocaleString(), showPercentage ? "%" : ""] }))] })] })) }, item.dataKey));
                }) })] }));
});
ChartTooltipContent.displayName = "ChartTooltip";
// this is not used any more, in the new chart, we are using the default legend which is rendered outside the charts container,
// older charts are still using this legend.
/**
 * Re-exported Legend component from Recharts
 */
const ChartLegend = RechartsPrimitive.Legend;
/**
 * Custom legend content component with enhanced styling
 */
const ChartLegendContent = forwardRef(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
    const { config } = useChart();
    const payloadWithKeys = useMemo(() => payload?.map((item) => ({
        ...item,
        uniqueKey: uniqueId(`chart-legend-${item.dataKey || item.value || ""}-`),
    })), [payload]);
    if (!payload?.length) {
        return null;
    }
    return (_jsx("div", { ref: ref, className: clsx("crayon-chart-legend", `crayon-chart-legend--${verticalAlign}`, className), children: payloadWithKeys?.map((item) => {
            const key = `${nameKey || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            return (_jsxs("div", { className: "crayon-chart-legend-item", children: [itemConfig?.icon && !hideIcon ? (_jsx(itemConfig.icon, {})) : (_jsx("div", { className: "crayon-chart-legend-item-indicator", style: { backgroundColor: item.color } })), _jsx("span", { className: "crayon-chart-legend-item-label", children: itemConfig?.label })] }, item.uniqueKey));
        }) }));
});
ChartLegendContent.displayName = "ChartLegend";
/**
 * Helper function to extract configuration for a chart element from a payload
 */
function getPayloadConfigFromPayload(config, payload, key) {
    if (typeof payload !== "object" || payload === null) {
        return undefined;
    }
    const payloadPayload = "payload" in payload && typeof payload.payload === "object" && payload.payload !== null
        ? payload.payload
        : undefined;
    let configLabelKey = key;
    if (key in payload && typeof payload[key] === "string") {
        configLabelKey = payload[key];
    }
    else if (payloadPayload &&
        key in payloadPayload &&
        typeof payloadPayload[key] === "string") {
        configLabelKey = payloadPayload[key];
    }
    return configLabelKey in config ? config[configLabelKey] : config[key];
}
export { ChartContainer, ChartLegend, ChartLegendContent, ChartStyle, ChartTooltip, ChartTooltipContent, getPayloadConfigFromPayload, useChart, };
//# sourceMappingURL=Charts.js.map