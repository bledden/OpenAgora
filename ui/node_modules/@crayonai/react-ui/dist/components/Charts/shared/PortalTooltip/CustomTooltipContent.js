import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import clsx from "clsx";
import { forwardRef, memo, useEffect, useMemo, useState } from "react";
import { ChartStyle, getPayloadConfigFromPayload, useChart } from "../../../Charts/Charts";
import { useSideBarTooltip } from "../../context/SideBarTooltipContext";
import { FloatingUIPortal } from "./FloatingUIPortal";
import { tooltipNumberFormatter } from "./utils";
const DEFAULT_INDICATOR = "dot";
/**
 * Custom tooltip content component for floating tooltips
 * Mirrors the functionality of ChartTooltipContent but works with FloatingUIPortal
 */
export const CustomTooltipContent = memo(forwardRef((props, ref) => {
    const { active, payload, className, indicator = DEFAULT_INDICATOR, hideLabel = false, hideIndicator = false, label, labelFormatter, labelClassName, formatter, color, nameKey, labelKey, showPercentage = false, portalContainer, parentRef, } = props;
    const { config, id } = useChart();
    const { isSideBarTooltipOpen } = useSideBarTooltip();
    const isGreaterThanTen = !!(payload?.length && payload.length > 10);
    const remainingItems = payload && isGreaterThanTen ? payload.length - 5 : 0;
    // this state is used to forcefully hide the tooltip when the user touches outside of the parent element
    // this is not handled by recharts
    const [forcefullyHideTooltip, setForcefullyHideTooltip] = useState(false);
    const tooltipLabel = useMemo(() => {
        if (hideLabel || !payload?.length) {
            return null;
        }
        const [item] = payload;
        const key = `${labelKey ?? item?.dataKey ?? item?.name ?? "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);
        const value = !labelKey && typeof label === "string" ? config[label]?.label || label : itemConfig?.label;
        // this is active when we pass a labelFormatter prop to the recharts tooltip
        // normally we would not need this, but it's useful for customizing the label
        if (labelFormatter) {
            return (_jsx("div", { className: clsx("crayon-chart-tooltip-label-heavy", labelClassName), children: labelFormatter(value, payload) }));
        }
        if (!value) {
            return null;
        }
        return _jsx("div", { className: clsx("crayon-chart-tooltip-label", labelClassName), children: value });
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);
    const nestLabel = useMemo(() => payload?.length === 1 && indicator !== DEFAULT_INDICATOR, [payload?.length, indicator]);
    const payloadItems = useMemo(() => {
        if (!payload?.length) {
            return [];
        }
        const renderPayloadItem = (item, index, isTwoItemsLayout) => {
            const key = `${nameKey ?? item.name ?? item.dataKey ?? "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = (color ?? item.payload?.fill) || item.color;
            return (_jsxs("div", { className: clsx("crayon-chart-tooltip-content-item", !isTwoItemsLayout &&
                    indicator === DEFAULT_INDICATOR &&
                    "crayon-chart-tooltip-content-item--dot"), children: [formatter && item?.value !== undefined && item.name ? (formatter(item.value, item.name, item, index, item.payload)) : (_jsxs(_Fragment, { children: [itemConfig?.icon ? (_jsx(itemConfig.icon, {})) : (!hideIndicator && (_jsx("div", { className: clsx("crayon-chart-tooltip-content-indicator", `crayon-chart-tooltip-content-indicator--${indicator}`, isTwoItemsLayout && "crayon-chart-tooltip-content-indicator--two-items"), style: {
                                    "--color-bg": indicatorColor,
                                    "--color-border": indicatorColor,
                                } }))), _jsxs("div", { className: clsx("crayon-chart-tooltip-content-value-wrapper", isTwoItemsLayout && "crayon-chart-tooltip-content-value-wrapper--vertical", nestLabel
                                    ? "crayon-chart-tooltip-content-value-wrapper--nested"
                                    : "crayon-chart-tooltip-content-value-wrapper--standard"), children: [_jsxs("div", { className: "crayon-chart-tooltip-content-label", children: [nestLabel && tooltipLabel, _jsx("span", { children: itemConfig?.label || item.name })] }), item.value !== undefined && (_jsxs("span", { className: clsx("crayon-chart-tooltip-content-value", showPercentage && "percentage"), children: [typeof item.value === "number"
                                                ? tooltipNumberFormatter(item.value)
                                                : item.value, showPercentage ? "%" : ""] }))] })] })), _jsx("div", { className: "crayon-chart-tooltip-content-item-separator" })] }, `${item.dataKey}-${index}`));
        };
        // Handle two items layout
        if (payload.length <= 2) {
            return payload.map((item, index) => renderPayloadItem(item, index, true));
        }
        // Handle regular layout with potential truncation
        const morphPayload = isGreaterThanTen ? payload.slice(0, 5) : payload;
        return morphPayload.map((item, index) => renderPayloadItem(item, index, false));
    }, [
        payload,
        nameKey,
        config,
        color,
        indicator,
        formatter,
        hideIndicator,
        nestLabel,
        tooltipLabel,
        showPercentage,
    ]);
    useEffect(() => {
        const parent = parentRef.current;
        if (!parent) {
            return;
        }
        const touchHandler = (e) => {
            for (let i = 0; i < e.targetTouches.length; i++) {
                const target = e.targetTouches[i].target;
                if (!parent.contains(target)) {
                    setForcefullyHideTooltip(true);
                    return;
                }
            }
            setForcefullyHideTooltip(false);
        };
        document.body.addEventListener("touchstart", touchHandler);
        return () => {
            document.body.removeEventListener("touchstart", touchHandler);
        };
    }, [parentRef.current]);
    // Early return for inactive or empty payload - moved after all hooks
    if (!active || !payload?.length || isSideBarTooltipOpen || forcefullyHideTooltip) {
        return null;
    }
    const tooltipContent = (_jsxs("div", { ref: ref, className: clsx("crayon-chart-tooltip", className), children: [!nestLabel && tooltipLabel, _jsx("div", { className: "crayon-chart-tooltip-content-item-separator" }), _jsx("div", { className: "crayon-chart-tooltip-content", children: payloadItems }), isGreaterThanTen && _jsx("div", { className: "crayon-chart-tooltip-content-item-separator" }), isGreaterThanTen && (_jsxs("div", { className: "crayon-chart-tooltip-content-view-more", children: ["Click to view all ", remainingItems] }))] }));
    return (_jsxs(FloatingUIPortal, { chartId: id, portalContainer: portalContainer, position: props.coordinate, children: [_jsx(ChartStyle, { id: id, config: config }), tooltipContent] }));
}));
CustomTooltipContent.displayName = "CustomTooltipContent";
//# sourceMappingURL=CustomTooltipContent.js.map