import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import clsx from "clsx";
import React, { useCallback, useMemo, useRef, useState } from "react";
import { Bar, BarChart as RechartsBarChart, XAxis, YAxis } from "recharts";
import { useId } from "../../../polyfills";
import { useTheme } from "../../ThemeProvider";
import { ChartContainer, ChartTooltip } from "../Charts";
import { X_AXIS_PADDING } from "../constants";
import { SideBarTooltipProvider } from "../context/SideBarTooltipContext";
import { useAutoAngleCalculation, useMaxLabelWidth, useTransformedKeys, useYAxisLabelWidth, } from "../hooks";
import { cartesianGrid, CondensedXAxisTick, CustomTooltipContent, LineInBarShape, YAxisTick, } from "../shared";
import { LabelTooltipProvider } from "../shared/LabelTooltip/LabelTooltip";
import { getBarStackInfo, getRadiusArray } from "../utils/BarCharts/BarChartsUtils";
import { get2dChartConfig, getDataKeys } from "../utils/dataUtils";
import { useChartPalette } from "../utils/PalletUtils";
const BAR_WIDTH = 16;
const BAR_GAP = 10;
const BAR_CATEGORY_GAP = "20%";
const BAR_INTERNAL_LINE_WIDTH = 1;
const BAR_RADIUS = 4;
const CHART_HEIGHT = 200;
const CHART_CONTAINER_BOTTOM_MARGIN = 10;
const BarChartCondensedComponent = ({ data, categoryKey, theme = "ocean", customPalette, variant = "grouped", tickVariant = "singleLine", grid = true, icons = {}, radius = BAR_RADIUS, isAnimationActive = false, showYAxis = true, className, height = CHART_HEIGHT, width, }) => {
    const dataKeys = useMemo(() => {
        return getDataKeys(data, categoryKey);
    }, [data, categoryKey]);
    const { yAxisWidth, setLabelWidth } = useYAxisLabelWidth(data, dataKeys);
    const maxLabelWidth = useMaxLabelWidth(data, categoryKey);
    const { angle: calculatedAngle, height: xAxisHeight } = useAutoAngleCalculation(maxLabelWidth, yAxisWidth, tickVariant === "angled", showYAxis);
    const effectiveHeight = useMemo(() => {
        if (tickVariant === "angled") {
            return xAxisHeight + height;
        }
        return height;
    }, [height, xAxisHeight, tickVariant]);
    const transformedKeys = useTransformedKeys(dataKeys);
    const colors = useChartPalette({
        chartThemeName: theme,
        customPalette,
        themePaletteName: "barChartPalette",
        dataLength: dataKeys.length,
    });
    const chartConfig = useMemo(() => {
        return get2dChartConfig(dataKeys, colors, transformedKeys, undefined, icons);
    }, [dataKeys, icons, colors, transformedKeys]);
    const id = useId();
    const chartMargin = useMemo(() => ({
        top: 10,
        right: 10,
        bottom: CHART_CONTAINER_BOTTOM_MARGIN,
        left: showYAxis ? 10 : 0,
    }), [showYAxis]);
    const { mode } = useTheme();
    const barInternalLineColor = useMemo(() => {
        if (mode === "light") {
            return "rgba(255, 255, 255, 0.3)";
        }
        return "rgba(0, 0, 0, 0.3)";
    }, [mode]);
    const containerRef = useRef(null);
    const [isSideBarTooltipOpen, setIsSideBarTooltipOpen] = useState(false);
    const [sideBarTooltipData, setSideBarTooltipData] = useState({
        title: "",
        values: [],
    });
    const [hoveredCategory, setHoveredCategory] = useState(null);
    // Handle mouse events for bar hovering
    const handleChartMouseMove = useCallback((state) => {
        if (state && state.activeLabel !== undefined) {
            setHoveredCategory(state.activeLabel);
        }
    }, []);
    const handleChartMouseLeave = useCallback(() => {
        setHoveredCategory(null);
    }, []);
    const barElements = useMemo(() => {
        return dataKeys.map((key) => {
            const transformedKey = transformedKeys[key];
            const color = `var(--color-${transformedKey})`;
            return (_jsx(Bar, { dataKey: key, fill: color, stackId: variant === "stacked" ? "a" : undefined, isAnimationActive: isAnimationActive, maxBarSize: BAR_WIDTH, barSize: BAR_WIDTH, shape: (props) => {
                    const { payload, value, dataKey } = props;
                    const { isNegative, isFirstInStack, isLastInStack, hasNegativeValueInStack } = getBarStackInfo(variant, value, dataKey, payload, dataKeys);
                    const customRadius = getRadiusArray(variant, radius, "vertical", isFirstInStack, isLastInStack, isNegative);
                    return (_jsx(LineInBarShape, { ...props, radius: customRadius, internalLineColor: barInternalLineColor, internalLineWidth: BAR_INTERNAL_LINE_WIDTH, isHovered: hoveredCategory !== null, hoveredCategory: hoveredCategory, categoryKey: categoryKey, variant: variant, hasNegativeValueInStack: hasNegativeValueInStack }));
                } }, `bar-${key}`));
        });
    }, [
        dataKeys,
        transformedKeys,
        variant,
        radius,
        isAnimationActive,
        barInternalLineColor,
        hoveredCategory,
        categoryKey,
    ]);
    return (_jsx(LabelTooltipProvider, { children: _jsx(SideBarTooltipProvider, { isSideBarTooltipOpen: isSideBarTooltipOpen, setIsSideBarTooltipOpen: setIsSideBarTooltipOpen, data: sideBarTooltipData, setData: setSideBarTooltipData, children: _jsx("div", { ref: containerRef, className: clsx("crayon-bar-chart-condensed", className), style: {
                    width: width ? `${width}px` : "100%",
                    height: `${effectiveHeight}px`,
                }, children: _jsx(ChartContainer, { config: chartConfig, style: { width: "100%", height: "100%" }, rechartsProps: {
                        width: "100%",
                        height: "100%",
                    }, children: _jsxs(RechartsBarChart, { accessibilityLayer: true, data: data, margin: chartMargin, barGap: BAR_GAP, barCategoryGap: BAR_CATEGORY_GAP, onMouseMove: handleChartMouseMove, onMouseLeave: handleChartMouseLeave, children: [grid && cartesianGrid(), _jsx(XAxis, { dataKey: categoryKey, tickLine: false, axisLine: false, textAnchor: tickVariant === "angled" ? "end" : "middle", interval: "preserveStartEnd", minTickGap: 5, height: xAxisHeight, tick: _jsx(CondensedXAxisTick, {}), angle: calculatedAngle, orientation: "bottom", padding: {
                                    left: X_AXIS_PADDING,
                                    right: X_AXIS_PADDING,
                                } }), showYAxis && (_jsx(YAxis, { tickLine: false, axisLine: false, tick: _jsx(YAxisTick, { setLabelWidth: setLabelWidth }), width: yAxisWidth })), _jsx(ChartTooltip, { cursor: {
                                    fill: "var(--crayon-sunk-fills)",
                                    stroke: "var(--crayon-stroke-default)",
                                    opacity: 1,
                                    strokeWidth: 1,
                                }, content: _jsx(CustomTooltipContent, { parentRef: containerRef }), offset: 10 }), barElements] }, `bar-chart-condensed-${id}`) }) }) }) }));
};
// Added React.memo for performance optimization to avoid unnecessary re-renders
export const BarChartCondensed = React.memo(BarChartCondensedComponent);
//# sourceMappingURL=BarChartCondensed.js.map