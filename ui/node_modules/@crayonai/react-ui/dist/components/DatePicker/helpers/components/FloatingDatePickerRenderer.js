import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { autoUpdate, flip, offset, useFloating } from "@floating-ui/react-dom";
import clsx from "clsx";
import { ChevronDown } from "lucide-react";
import { forwardRef, useEffect, useRef } from "react";
import { createPortal } from "react-dom";
import { useMultipleRefs } from "../../../../hooks/useMultipleRefs";
import { useTheme } from "../../../ThemeProvider";
import { useDatePicker } from "../context/DatePickerContext";
import { formatDateRange, formatSingleDate } from "../utils/helperFn";
import { DatepickerRenderer } from "./DatePickerRenderer";
const FloatingDateInput = () => {
    const { mode, selectedDate, selectedRange, isOpen, setIsOpen } = useDatePicker();
    const hasSelectedDate = mode === "single"
        ? !!selectedDate
        : !!(selectedRange && selectedRange.from && selectedRange.to);
    return (_jsxs("div", { className: clsx("crayon-date-picker-renderer-floating-input-container", {
            "crayon-date-picker-renderer-floating-input-container-open": isOpen,
            "crayon-date-picker-renderer-floating-input-container-not-open": !isOpen,
            "crayon-date-picker-renderer-floating-input-container-has-no-selected-date": !hasSelectedDate,
        }), onClick: (e) => {
            e.stopPropagation();
            setIsOpen(!isOpen);
        }, children: [_jsx("span", { className: "crayon-date-picker-renderer-floating-input-container-text", children: mode === "single" ? formatSingleDate(selectedDate) : formatDateRange(selectedRange) }), _jsx(ChevronDown, { size: 16, className: clsx({ "crayon-date-picker-renderer-floating-input-container-icon": isOpen }) })] }));
};
const FloatingDatePicker = forwardRef((_, ref) => {
    const { isOpen } = useDatePicker();
    const menuPositionDivRef = useRef(null);
    const { portalThemeClassName } = useTheme();
    const { refs: { setFloating, setReference }, floatingStyles, } = useFloating({
        strategy: "absolute",
        placement: "bottom-start",
        whileElementsMounted: autoUpdate,
        middleware: [offset(5), flip()],
    });
    const menuPositionDivRefs = useMultipleRefs(setReference, menuPositionDivRef);
    const floatingRef = useMultipleRefs(setFloating, ref);
    if (!isOpen) {
        return null;
    }
    return (_jsxs(_Fragment, { children: [_jsx("div", { ref: menuPositionDivRefs, className: clsx("crayon-date-picker-renderer-floating-reference") }), createPortal(_jsx("div", { ref: floatingRef, style: { ...floatingStyles, width: "fit-content" }, className: clsx("crayon-date-picker-renderer-floating-content", portalThemeClassName), children: _jsx("div", { className: "crayon-date-picker-renderer-floating-menu", children: _jsx(DatepickerRenderer, {}) }) }), document.body)] }));
});
export const FloatingDatePickerRenderer = ({ className, style, }) => {
    const { isOpen, setIsOpen } = useDatePicker();
    const menuRef = useRef(null);
    useEffect(() => {
        if (!isOpen)
            return;
        const handleClick = (e) => {
            if (menuRef.current?.contains(e.target)) {
                return;
            }
            setIsOpen(false);
        };
        document.body.addEventListener("click", handleClick);
        return () => {
            document.body.removeEventListener("click", handleClick);
        };
    }, [isOpen, setIsOpen]);
    return (_jsxs("div", { className: clsx("crayon-date-picker-renderer-floating-container", className), style: style, children: [_jsx(FloatingDateInput, {}), _jsx(FloatingDatePicker, { ref: menuRef })] }));
};
//# sourceMappingURL=FloatingDatePickerRenderer.js.map