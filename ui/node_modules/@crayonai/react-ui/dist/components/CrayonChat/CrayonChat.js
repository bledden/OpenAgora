import { jsx as _jsx } from "react/jsx-runtime";
import { ChatProvider, processStreamedMessage, useThreadListManager, useThreadManager, } from "@crayonai/react-core";
import { useEffect, useRef } from "react";
import invariant from "tiny-invariant";
import { ThemeProvider } from "../ThemeProvider";
import { ComposedCopilot } from "./ComposedCopilot";
import { ComposedStandalone } from "./ComposedStandalone";
const DummyThemeProvider = ({ children }) => {
    return children;
};
export const CrayonChat = ({ processMessage, threadManager: userThreadManager, threadListManager: userThreadListManager, logoUrl = "https://crayonai.org/img/logo.png", agentName = "My Agent", responseTemplates, createThread, onUpdateMessage, processStreamedMessage: userProcessStreamedMessage, messageLoadingComponent, type = "standalone", theme, scrollVariant = "user-message-anchor", disableThemeProvider, }) => {
    invariant(processMessage || userThreadManager, "processMessage or threadManager is required");
    const ThemeProviderComponent = disableThemeProvider ? DummyThemeProvider : ThemeProvider;
    const threadMessages = useRef({});
    const defaultThreadListManager = useThreadListManager({
        fetchThreadList: () => Promise.resolve([]),
        deleteThread: () => Promise.resolve(),
        updateThread: (t) => Promise.resolve(t),
        onSwitchToNew: () => { },
        onSelectThread: () => { },
        createThread: (message) => {
            if (createThread) {
                return createThread(message);
            }
            return Promise.resolve({
                threadId: crypto.randomUUID(),
                title: message.message,
                createdAt: new Date(),
                messages: [message],
            });
        },
    });
    const threadListManager = userThreadListManager ?? defaultThreadListManager;
    const defaultThreadManager = useThreadManager({
        threadId: threadListManager.selectedThreadId,
        shouldResetThreadState: threadListManager.shouldResetThreadState,
        loadThread: (threadId) => {
            const messages = threadMessages.current[threadId] ?? [];
            return Promise.resolve(messages);
        },
        onUpdateMessage: onUpdateMessage,
        onProcessMessage: async ({ message, abortController, threadManager }) => {
            const newMessage = {
                id: crypto.randomUUID(),
                ...message,
            };
            threadManager.appendMessages(newMessage);
            let threadId = threadListManager.selectedThreadId;
            if (!threadId) {
                const newThread = await threadListManager.createThread(message);
                threadId = newThread.threadId;
                threadListManager.selectThread(threadId, false);
            }
            invariant(processMessage, "processMessage is required");
            const response = await processMessage({
                threadId,
                messages: [...threadManager.messages, newMessage],
                abortController,
            });
            await (userProcessStreamedMessage || processStreamedMessage)({
                response,
                createMessage: threadManager.appendMessages,
                updateMessage: threadManager.updateMessage,
                deleteMessage: threadManager.deleteMessage,
            });
            return [];
        },
        responseTemplates: responseTemplates ?? [],
    });
    const threadManager = userThreadManager ?? defaultThreadManager;
    useEffect(() => {
        if (threadListManager.selectedThreadId) {
            threadMessages.current[threadListManager.selectedThreadId] = threadManager.messages;
        }
    }, [threadManager.messages]);
    return (_jsx(ThemeProviderComponent, { ...theme, children: _jsx(ChatProvider, { threadListManager: threadListManager, threadManager: threadManager, children: type === "copilot" ? (_jsx(ComposedCopilot, { logoUrl: logoUrl, agentName: agentName, messageLoadingComponent: messageLoadingComponent, scrollVariant: scrollVariant })) : (_jsx(ComposedStandalone, { logoUrl: logoUrl, agentName: agentName, messageLoadingComponent: messageLoadingComponent, scrollVariant: scrollVariant })) }) }));
};
//# sourceMappingURL=CrayonChat.js.map