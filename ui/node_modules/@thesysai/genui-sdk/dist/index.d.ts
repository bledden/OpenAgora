import { AssistantMessage } from '@crayonai/react-core';
import { default as default_2 } from 'react';
import { IconButtonProps } from '@crayonai/react-ui';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { MemoExoticComponent } from 'react';
import { Message as Message_2 } from '@crayonai/react-core';
import { ReactNode } from 'react';
import { Theme } from '@crayonai/react-ui';
import { ThemeMode } from '@crayonai/react-ui/ThemeProvider';
import { ThemeProps } from '@crayonai/react-ui/ThemeProvider';
import { ThreadListManager } from '@crayonai/react-core';
import { ThreadManager } from '@crayonai/react-core';
import { useThreadListManager } from '@crayonai/react-core';

export declare type ArtifactActionComponent = React.ComponentType<{
    artifactId: string;
    artifactType: string;
}>;

export declare enum ArtifactViewMode {
    AUTO_OPEN = "AUTO_OPEN",
    OPEN_ON_MOUNT = "OPEN_ON_MOUNT",
    OVERVIEW = "OVERVIEW"
}

declare type C1Action = C1ActionEvent & LegacyAction;

declare type C1ActionEvent = {
    type?: string;
    params?: Record<string, any>;
};

export declare const C1Chat: ({ processMessage, threadManager: userThreadManager, threadListManager: userThreadListManager, type, theme: userTheme, agentName, logoUrl, apiUrl, scrollVariant, formFactor: passedFormFactor, customizeC1, disableThemeProvider, generateShareLink, onAction, }: {
    threadManager?: ThreadManager;
    threadListManager?: ThreadListManager;
    processMessage?: (params: {
        threadId: string;
        messages: {
            id: string;
            role: "user" | "assistant";
            content: string;
        }[];
        responseId: string;
        abortController: AbortController;
    }) => Promise<Response>;
    /**
     * @deprecated use `formFactor` instead
     */
    type?: "copilot" | "standalone";
    formFactor?: "full-page" | "side-panel";
    /**
     * @deprecated wrap C1Chat with ThemeProvider instead of passing theme here
     */
    theme?: Omit<ThemeProps, "children">;
    agentName?: string;
    logoUrl?: string;
    apiUrl?: string;
    scrollVariant?: "once" | "user-message-anchor" | "always";
    customizeC1?: {
        customComponents?: CustomComponentLibrary;
        thinkComponent?: ThinkComponent;
        responseFooterComponent?: ResponseFooterComponent;
        artifactViewMode?: ArtifactViewMode;
        artifactActionComponent?: ArtifactActionComponent;
    };
    disableThemeProvider?: boolean;
    generateShareLink?: (messages: Message[]) => Promise<string>;
    onAction?: OnAction;
}) => JSX_2.Element;

export declare const C1ChatViewer: ({ messages, loadMessages, formFactor, logoUrl, agentName, }: C1ChatViewerProps) => JSX_2.Element;

export declare type C1ChatViewerProps = {
    formFactor?: 'full-page' | 'side-panel';
    logoUrl?: string;
    agentName?: string;
    messages?: Message[];
    loadMessages?: () => Promise<Message[]>;
};

export declare const C1Component: MemoExoticComponent<(props: C1ComponentProps) => JSX_2.Element>;

declare type C1ComponentInternalProps = {
    c1Response: string;
    isStreaming: boolean;
    updateMessage?: (message: string) => void;
    onAction?: OnAction;
    searchImage?: (query: string) => Promise<{
        url: string;
        thumbnailUrl?: string;
    }>;
    thinkComponent?: ThinkComponent;
    onError?: (error: {
        code: number;
        c1Response: string;
    }) => void;
    customComponents?: CustomComponentLibrary;
    artifactViewMode?: ArtifactViewMode;
    disableArtifactClose?: boolean;
    artifactActionComponent?: ArtifactActionComponent;
};

declare type C1ComponentProps = Omit<C1ComponentInternalProps, 'searchImage'>;

declare type C1ContextType = {
    formContext?: FormContextType;
    useOnAction: () => (userMessage: string, actionContext: string, formName?: string, action?: {
        type?: string;
        params?: any;
    }) => void;
    searchImage?: (query: string) => Promise<{
        url: string;
        thumbnailUrl?: string;
    }>;
    useIsStreaming: () => boolean;
    customComponents?: CustomComponentLibrary;
    artifactViewMode: ArtifactViewMode;
    disableArtifactClose: boolean;
    artifactActionComponent?: ArtifactActionComponent;
};

export declare const C1ShareModal: default_2.FC<C1ShareThreadModalProps>;

export declare const C1ShareThread: ({ modalTitle, generateShareLink, customTrigger, }: C1ShareThreadProps) => JSX_2.Element | null;

declare interface C1ShareThreadModalProps {
    /**
     * The title of the modal. If not provided, the default title will be used.
     */
    title?: string;
    /**
     * The trigger that opens the modal.
     */
    trigger: ReactNode;
    /**
     * A function that returns a promise that resolves to the generated link.
     */
    generateLink: () => Promise<string>;
    /**
     * The theme class name to apply to the modal. if not provided, the default wrapping theme would be used
     */
    themeClassName?: string;
}

declare interface C1ShareThreadProps {
    /**
     * The title of the modal that opens when the share button is clicked.
     */
    modalTitle?: string;
    /**
     * A function that returns a promise that resolves to the generated link.
     */
    generateShareLink?: (messages: Message[]) => Promise<string>;
    /**
     * Custom trigger to open the modal. If not provided, a default share button will be used.
     */
    customTrigger?: ReactNode;
}

export declare const C1TemplateForCrayon: {
    name: string;
    Component: MemoExoticComponent<({ content }: {
    content?: string;
    }) => JSX_2.Element | null>;
};

declare type CustomComponentLibrary = Record<string, default_2.ComponentType<any>>;

declare type FormContextType = {
    useGetFieldValue: () => (formName: string | undefined, name: string) => any;
    useSetFieldValue: () => (formName: string | undefined, componentType: string | undefined, name: string, value: any, shouldTriggerSaveCallback?: boolean) => void;
};

export declare const fromOpenAIMessage: (message: OpenAIMessage) => Message_2;

export declare const fromOpenAIMessages: (messages: OpenAIMessage[]) => Message_2[];

export declare const getC1Theme: (userTheme?: Omit<ThemeProps, "children">) => {
    mode: ThemeMode | undefined;
    theme: Theme | undefined;
    darkTheme: Theme | undefined;
};

/**
 * @deprecated Use the structured `params` property in `C1ActionEvent` instead.
 * This legacy format is maintained for backward compatibility only.
 *
 * Migration:
 * - Instead of accessing `event.humanFriendlyMessage` and `event.llmFriendlyMessage` directly,
 * - Use `event.params.humanFriendlyMessage` and `event.params.llmFriendlyMessage`
 *
 * @see C1ActionEvent for the new structured action format
 */
declare type LegacyAction = {
    humanFriendlyMessage: string;
    llmFriendlyMessage: string;
};

export declare const makeC1ShareArtifact: ({ generateShareLink }: MakeC1ShareArtifactOptions) => ({ artifactId, artifactType, }: {
    artifactId: string;
    artifactType: string;
}) => JSX_2.Element;

declare interface MakeC1ShareArtifactOptions {
    generateShareLink: (artifactId: string, artifactType: string, message: Message, threadId: string) => Promise<string>;
}

export declare const makeC1TemplateForCrayon: ({ onError, searchImage, thinkComponent, responseFooterComponent: ResponseFooterComponent, customComponents, onAction: userOnAction, artifactViewMode, disableArtifactClose, artifactActionComponent, }: MakeC1TemplateForCrayonOptions) => {
    name: string;
    Component: MemoExoticComponent<({ content }: {
    content?: string;
    }) => JSX_2.Element | null>;
};

declare interface MakeC1TemplateForCrayonOptions {
    onError?: (error: {
        code: number;
        c1Response: string;
    }) => void;
    searchImage?: C1ContextType['searchImage'];
    thinkComponent?: ThinkComponent;
    responseFooterComponent?: ResponseFooterComponent;
    customComponents?: CustomComponentLibrary;
    onAction?: OnAction;
    artifactViewMode?: ArtifactViewMode;
    disableArtifactClose?: boolean;
    artifactActionComponent?: ArtifactActionComponent;
}

export declare type Message = {
    id: string;
    role: 'user' | 'assistant';
    content?: string;
};

declare type OnAction = (event: C1Action) => void;

declare type OpenAIMessage = {
    id: string;
    role: 'user' | 'assistant';
    content?: string;
    tool_calls?: any[];
};

export declare const processStreamedMessage: ({ response, createMessage, updateMessage, id, }: {
    response: Response;
    createMessage: (message: AssistantMessage) => void;
    updateMessage: (message: AssistantMessage) => void;
    id: string;
}) => Promise<void>;

export declare namespace ResponseFooter {
    export {
        ShareButton,
        ThumbsDownButton,
        ThumbsUpButton,
        ResponseFooterContainer as Container
    }
}

export declare type ResponseFooterComponent = React.ComponentType<{
    threadId: string;
    messageId: string;
} & object>;

declare const ResponseFooterContainer: React.FC<React.PropsWithChildren<ResponseFooterContainerProps>>;

declare interface ResponseFooterContainerProps {
    className?: string;
    animate?: boolean;
}

declare type ResponseFooterShareButtonProps = Omit<IconButtonProps, 'icon'> & {
    generateShareLink: (messages: Message) => Promise<string>;
};

declare const ShareButton: ({ generateShareLink, ...props }: ResponseFooterShareButtonProps) => JSX_2.Element;

export declare const ThemeProvider: ({ children: passedChildren, ...userTheme }: ThemeProps) => JSX_2.Element;

export declare type ThinkComponent = default_2.ComponentType<ThinkStateProps>;

declare interface ThinkItem {
    title: string;
    content: string;
    ephemeral: boolean;
}

declare type ThinkStateProps = {
    thinkItems: ThinkItem[];
    thinkingInProgress: boolean;
};

declare const ThumbsDownButton: default_2.ForwardRefExoticComponent<Omit<IconButtonProps, "icon"> & default_2.RefAttributes<HTMLButtonElement>>;

declare const ThumbsUpButton: default_2.ForwardRefExoticComponent<Omit<IconButtonProps, "icon"> & default_2.RefAttributes<HTMLButtonElement>>;

export declare const toOpenAIMessage: (message: Message_2) => any;

export declare const toOpenAIMessages: (messages: Message_2[]) => any[];

export declare const useArtifact: () => {
    isArtifactActive: any;
    renderArtifact: () => JSX_2.Element;
    activeArtifact: any;
};

/**
 * Access a named piece of component state with getter and setter helpers.
 *
 * - name: the state field key you wish to read/write.
 * - getValue(): returns the current value for the given field.
 * - setValue(value): updates the field and triggers any save/persist callbacks.
 *
 * @param {string} name - The state field name to manage.
 * @returns {{ getValue: () => any, setValue: (value: any) => void }}
 *          Helpers for reading and writing the field.
 *
 * @example
 * const { getValue, setValue } = useC1State('note');
 * const note = getValue() || '';
 * setValue(note);
 *
 * @example
 * const { getValue, setValue } = useC1State('note');
 * <input
 *   value={getValue() || ''}
 *   onChange={e => setValue(e.target.value)}
 * />
 */
export declare const useC1State: (name: string) => {
    getValue: () => any;
    setValue: (value: any) => void;
};

/**
 * Indicates whether the system is currently streaming a response from the LLM.
 *
 * Useful to disable inputs/UI during in-progress generation.
 *
 * @returns {boolean} True while streaming; false otherwise.
 *
 * @example
 * const isStreaming = useIsStreaming();
 * return <button disabled={isStreaming}>Send</button>;
 */
export declare const useIsStreaming: () => boolean;

/**
 * Returns a callback to record a user action with both a user-facing label and an LLM-oriented description.
 *
 * - humanFriendlyMessage: shown to the user (e.g., button label, toast).
 * - llmFriendlyMessage: detailed, machine-oriented context sent to the LLM.
 *
 * @param {string} humanFriendlyMessage - Visible to the user; concise, human-readable label for the action.
 * @param {string} llmFriendlyMessage - Sent to the LLM; richer context describing what happened.
 * @returns {(humanFriendlyMessage: string, llmFriendlyMessage: string) => void} Callback to dispatch the action.
 *
 * @example
 * const onAction = useOnAction();
 * onAction('Save', 'User saved the form with the following values: ${JSON.stringify(values)}');
 */
export declare const useOnAction: () => (humanFriendlyMessage: string, llmFriendlyMessage: string) => void;

/**
 * A hook for managing a list of messages that can be selected to share, with an share mode for selection.
 * @param options - Configuration options for the hook.
 * @param options.initialMessages - An optional array of messages to initialize the state with.
 * @param options.shareMode - A boolean to enable or disable selection mode.
 * @returns An object containing the current messages and functions to manage them.
 */
export declare const useShareMessages: ({ initialMessages, shareMode, }?: UseShareMessagesOptions) => {
    addMessage: (message: Message) => void;
    isMessageSelected: (message: Message) => boolean;
    removeMessage: (messageToRemove: Message) => void;
    selectedMessages: Message[];
    shareMode: boolean;
    toggleMessageSelection: (message: Message) => void;
    updateSelectedMessages: (messagesToUpdate: Message[], mode?: "append" | "replace") => void;
};

declare interface UseShareMessagesOptions {
    initialMessages?: Message[];
    shareMode?: boolean;
}

/**
 * Hook for sharing entire conversation threads with automatic message selection management.
 *
 * This hook provides a simplified interface for sharing complete threads without requiring
 * manual management of individual message selection. It automatically selects all messages
 * in the thread, eliminating the overhead of adding/removing selected messages.
 *
 * @example
 * ```tsx
 * const { selectedMessages, getShareThreadLink } = useShareThread({
 *   generateShareLink: async (messages) => {
 *     return await createShareLink(messages)
 *   }
 * })
 *
 */
export declare const useShareThread: ({ generateShareLink, }: UseShareThreadOptions) => {
    shouldDisableShareButton: boolean | undefined;
    selectedMessages: Message[];
    getShareThreadLink: () => Promise<string>;
};

declare interface UseShareThreadOptions {
    generateShareLink: (messages: Message[]) => Promise<string>;
}

export { useThreadListManager }

export declare const useThreadManager: ({ threadListManager, loadThread, processMessage, onUpdateMessage, apiUrl, customizeC1, isDisabled, onAction, }: {
    threadListManager: ThreadListManager;
    loadThread: (threadId: string) => Promise<Message[]>;
    processMessage?: (params: {
        threadId: string;
        messages: Message[];
        responseId: string;
        abortController: AbortController;
    }) => Promise<Response>;
    apiUrl?: string;
    onUpdateMessage: (props: {
        message: Message;
    }) => void;
    customizeC1?: {
        thinkComponent?: ThinkComponent;
        responseFooterComponent?: ResponseFooterComponent;
        customComponents?: CustomComponentLibrary;
        artifactViewMode?: ArtifactViewMode;
        disableArtifactClose?: boolean;
        artifactActionComponent?: ArtifactActionComponent;
    };
    isDisabled?: boolean;
    onAction?: OnAction;
}) => ThreadManager;

export { }


declare module '@tanstack/react-table' {
    interface TableMeta<TData extends RowData> {
        updateData: (rowIndex: number, columnId: string, value: unknown) => void;
    }
    interface ColumnMeta<TData extends RowData, TValue> {
        type?: CellType;
        options?: Array<{
            value: string;
            label: string;
        }>;
    }
}
